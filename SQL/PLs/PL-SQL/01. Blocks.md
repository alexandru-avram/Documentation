# Blocks

The structure of a PL/SQL script is foundational, and it's designed to be readable and modular. Here's the breakdown of a typical anonymous PL/SQL block, which is the basic unit of PL/SQL:

## Structure of a PL/SQL block

 1. DECLARE (Optional)
 2. BEGIN (Required)
 3. EXCEPTION (Optional)
 4. END; (Required)

### DECLARE Section
This is where you define variables, constants, cursors, types, etc.

```
DECLARE
  v_employee_id NUMBER;
  v_employee_name VARCHAR2(100);
  v_salary NUMBER := 5000;
```

### BEGIN Section
The main execution block where you write logic: calculations, control flow, queries, etc.

```
BEGIN
  v_employee_id := 101;
  v_employee_name := 'Alex';
  DBMS_OUTPUT.PUT_LINE('Employee: ' || v_employee_name);
```

### EXCEPTION Section
Handles errors that might occur during the execution phase.

```
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No matching employee found.');
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('An unexpected error occurred.');
```

### END;
Ends the PL/SQL block.

```
END;
```


### Full Example

```
DECLARE
  v_employee_id NUMBER := 101;
  v_employee_name VARCHAR2(100);
BEGIN
  -- Simulating assignment
  v_employee_name := 'Alex';

  -- Output
  DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employee_id);
  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_name);

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error occurred: ' || SQLERRM);
END;
/
```

## Types of Blocks

### Anonymous Blocks
These are unnamed and not stored in the database. They're often used for ad-hoc tasks, testing, or scripting.

```
DECLARE
  -- Declarations (optional)
BEGIN
  -- Logic (required)
EXCEPTION
  -- Error handling (optional)
END;
```

### Named Blocks
These are named program units that can be stored in the database for reuse.

#### Procedures
Perform an action (no return value).

```
CREATE OR REPLACE PROCEDURE greet_user(p_name VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name);
END;
```

#### Functions
Return a single value.

```
CREATE OR REPLACE FUNCTION get_tax(salary NUMBER) RETURN NUMBER IS
BEGIN
  RETURN salary * 0.1;
END;
```

#### Packages
Group related procedures/functions and share variables between them. Unlike anonymous blocks, procedures, and functions, packages are collections of related procedures and functions rather than individual types of blocks themselves.

```
CREATE OR REPLACE PACKAGE BODY math_ops IS
  FUNCTION add(x NUMBER, y NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN x + y;
  END;
  FUNCTION subtract(x NUMBER, y NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN x - y;
  END;
END math_ops;
```

#### Triggers
Automatically execute in response to table/view events (INSERT, UPDATE, DELETE)

```
CREATE OR REPLACE TRIGGER trg_set_created_at
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
  :NEW.created_at := SYSDATE;
END;
```

## Outputs
Outputs generally refer to how we display or return data from blocks, procedures, or functions.

### Output in Anonymous Blocks
Using `DBMS_OUTPUT.PUT_LINE` (most common for debugging)

```
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, World!');
END;
```

You can print variables for debugging:

```
DECLARE
  v_name VARCHAR2(50) := 'Alex';
BEGIN
  DBMS_OUTPUT.PUT_LINE('Name is: ' || v_name);
END;
```

### Output from Functions
Functions return a single value that can be captured or used in SQL or PL/SQL.

```
CREATE OR REPLACE FUNCTION get_bonus(salary NUMBER) RETURN NUMBER IS
BEGIN
  RETURN salary * 0.1;
END;

----- Call it 

DECLARE
  v_bonus NUMBER;
BEGIN
  v_bonus := get_bonus(5000);
  DBMS_OUTPUT.PUT_LINE('Bonus: ' || v_bonus);
END;
```

### Output Parameters in Procedures
Procedures don’t return values, but they can use `OUT` or `IN OUT` parameters to pass back results.

```
CREATE OR REPLACE PROCEDURE get_employee_name(
  p_id IN NUMBER,
  p_name OUT VARCHAR2
) IS
BEGIN
  SELECT name INTO p_name FROM employees WHERE id = p_id;
END;

----- Call it

DECLARE
  v_name VARCHAR2(100);
BEGIN
  get_employee_name(101, v_name);
  DBMS_OUTPUT.PUT_LINE('Employee name: ' || v_name);
END;
```

### Output from Triggers
Triggers don't return values or output directly, but they can log data, update tables, or call procedures.

```
CREATE OR REPLACE TRIGGER trg_log_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
  INSERT INTO log_table(action_type, timestamp)
  VALUES ('INSERT', SYSDATE);
END;
```

## Nested blocks
A nested block is a PL/SQL block written inside another block. You can nest blocks as deeply as you want, and each block has its own DECLARE, BEGIN, EXCEPTION, END structure.

They’re useful for:
* Scoping variables
* Isolating logic or exception handling
* Improving readability

You can use labels to improve readability and control flow in complex nested blocks.

```
DECLARE <<outer_block>>
  v_outer_var VARCHAR2(100) := 'Outer';

BEGIN
  DBMS_OUTPUT.PUT_LINE('Outer block start: ' || v_outer_var);

  DECLARE <<inner_block>>
    v_inner_var VARCHAR2(100) := 'Inner';
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Inner block: ' || v_inner_var);
    DBMS_OUTPUT.PUT_LINE('Access outer var: ' || v_outer_var);
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('Error in inner block');
  END; <<inner_block>>

  DBMS_OUTPUT.PUT_LINE('Outer block end');

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error in outer block');
END; <<outer_block>>
```

## Delimiters
In PL/SQL, delimiters are symbols that structure code.


Delimiter	Meaning
* `;`	Statement terminator
* `/`	Block terminator (in SQL*Plus, Oracle SQL Developer)
* `:=`	Assignment operator (assign value to variable)
* `--`	Single-line comment
* `/* */`	Multi-line comment
* `' '`	Encloses string literals
