# Cursors

A cursor is a pointer (or a handle) to a memory area called the context area where Oracle processes SQL statements and stores the result set. You often want to process rows one at a time, using logic (IFs, calculations, logging, etc.) That’s where cursors come in — they allow row-by-row iteration over query results

Think of a cursor like a bookmark or a pointer that helps you:
 - Access the rows of a SQL query one by one
 - Keep track of the current position
 - Control how data is fetched, processed, or looped over

## Type of Cursors

There are two main types of cursors

| Cursor Type         | Description                            | Use Case                        |
| ------------------- | -------------------------------------- | ------------------------------- |
| **Implicit Cursor** | Auto-created for single-row DML/SELECT | Simple, one-time use            |
| **Explicit Cursor** | Declared and controlled manually       | Multi-row queries, more control |

### Implicit Cursors
Oracle automatically creates them for you when you run a `SELECT INTO`, `INSERT`, `UPDATE`, or `DELETE`.

```
DECLARE
  v_name employees.name%TYPE;
BEGIN
  SELECT name INTO v_name FROM employees WHERE id = 101;
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
END;
```

Status Info (with `%` attributes):
- `SQL%ROWCOUNT` – how many rows affected
- `SQL%FOUND` – TRUE if at least one row affected
- `SQL%NOTFOUND` – TRUE if no rows affected
- `SQL%ISOPEN` – always FALSE for implicit cursors

### Explicit Cursors
You declare the cursor yourself and control:
- Declaring
- Opening
- Fetching
- Closing

```
DECLARE
  CURSOR emp_cur IS
    SELECT id, name FROM employees;

  v_id employees.id%TYPE;
  v_name employees.name%TYPE;
BEGIN
  OPEN emp_cur;
  LOOP
    FETCH emp_cur INTO v_id, v_name;
    EXIT WHEN emp_cur%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE('[' || v_id || '] ' || v_name);
  END LOOP;
  CLOSE emp_cur;
END;
```


## Cursor Lifecycle

| Step    | Description                                        |
| ------- | -------------------------------------------------- |
| Declare | Define the query and create the cursor             |
| Open    | Run the query and populate the result set          |
| Fetch   | Retrieve the current row into variables or records |
| Close   | Release the memory/resources used by the cursor    |

## Cursor Attributes

| Attribute   | Description                                 |
| ----------- | ------------------------------------------- |
| `%ISOPEN`   | TRUE if the cursor is currently open        |
| `%FOUND`    | TRUE if the last fetch returned a row       |
| `%NOTFOUND` | TRUE if the last fetch did NOT return a row |
| `%ROWCOUNT` | Number of rows fetched so far               |

```
DECLARE
  -- Declare a cursor to fetch employee ID and name from a specific department
  CURSOR emp_cur IS
    SELECT id, name FROM employees WHERE department_id = 10;

  -- Declare variables to hold fetched values
  v_id   employees.id%TYPE;
  v_name employees.name%TYPE;

BEGIN
  -- Check if the cursor is open before using it (should be FALSE initially)
  IF emp_cur%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor is unexpectedly already open!');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Cursor is initially closed.');
  END IF;

  -- Open the cursor manually
  OPEN emp_cur;

  -- After opening, ISOPEN should now return TRUE
  IF emp_cur%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor is now open.');
  END IF;

  -- Loop through the cursor manually using FETCH
  LOOP
    FETCH emp_cur INTO v_id, v_name;

    -- Check if a row was fetched (opposite of %NOTFOUND)
    IF emp_cur%FOUND THEN
      -- Print the current row's values
      DBMS_OUTPUT.PUT_LINE('Row ' || emp_cur%ROWCOUNT || ': ' || v_id || ' - ' || v_name);
    ELSE
      -- Exit the loop if no more rows
      EXIT;
    END IF;
  END LOOP;

  -- Close the cursor
  CLOSE emp_cur;

  -- Final confirmation that cursor is closed
  IF NOT emp_cur%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor has been closed.');
  END IF;
END;
```

What This Example Covers:
- Checks `%ISOPEN` before and after opening/closing the cursor
- Uses `%FOUND` and `%NOTFOUND` to control the loop
- Uses `%ROWCOUNT` to display the number of rows processed
- Safely closes the cursor at the end

## Cursor in Loops

### FOR LOOP (Simplest)
This method lets Oracle handle OPEN, FETCH, and CLOSE automatically. Much cleaner, ideal for most use cases.

[Other examples](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/Looping%20with%20Cursors.sql)

## Parameterized Cursors
You can pass parameters into cursors like functions.


```
DECLARE
  CURSOR emp_cur(p_dept_id NUMBER) IS
    SELECT id, name FROM employees WHERE department_id = p_dept_id;

  v_id employees.id%TYPE;
  v_name employees.name%TYPE;
BEGIN
  OPEN emp_cur(20);
  LOOP
    FETCH emp_cur INTO v_id, v_name;
    EXIT WHEN emp_cur%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE(v_id || ': ' || v_name);
  END LOOP;
  CLOSE emp_cur;
END;
```

## Cursors + RECORD
You can use a RECORD instead of multiple variables.

```
DECLARE
  TYPE r_emp IS RECORD (v_first_name employees.first_name%type,
                        v_last_name employees.last_name%type);
  v_emp r_emp;
  CURSOR c_emps IS SELECT first_name, last_name FROM employees;
BEGIN
  OPEN c_emps;
  FETCH c_emps into v_emp;
  DBMS_OUTPUT.PUT_LINE(v_emp.v_first_name|| ' ' || v_emp.v_last_name);
  CLOSE c_emps;
END;
```

## FOR UPDATE
This is crucial when:
- You want to lock rows for update before modifying them.
- You plan to fetch data row-by-row, perform logic, and then UPDATE or DELETE those exact rows safely.
- You're building concurrent-safe ETL or maintenance processes.

When you use FOR UPDATE in a cursor, Oracle:
- Locks the selected rows when the cursor is opened
- Prevents other sessions from modifying or deleting those rows until your transaction is committed or rolled back

```
CURSOR cur IS
  SELECT ... FROM table
  WHERE ... 
  FOR UPDATE [OF column1, column2] [NOWAIT | SKIP LOCKED];
```

| Step         | Description                                       |
| ------------ | ------------------------------------------------- |
| `FOR UPDATE` | Locks all rows returned by the cursor immediately |
| Cursor Loop  | Processes each row using fetched values           |
| `UPDATE`     | Applies changes inside the loop                   |
| `COMMIT`     | Releases the row locks                            |

```
DECLARE
  -- Declare cursor with FOR UPDATE to lock matching rows
  CURSOR emp_cur IS
    SELECT id, salary
    FROM employees
    WHERE department_id = 30
    FOR UPDATE OF salary;  -- Optional, tells Oracle which column will be updated

BEGIN
  -- Loop through each locked row
  FOR emp_rec IN emp_cur LOOP
    -- Give a 10% salary raise to each employee
    UPDATE employees
    SET salary = emp_rec.salary * 1.10
    WHERE id = emp_rec.id;

    DBMS_OUTPUT.PUT_LINE('Updated salary for Employee ID ' || emp_rec.id);
  END LOOP;

  -- Final commit to release row locks
  COMMIT;
END;
```

### NOWAIT: Don't Wait, Just Fail
- If the row is already locked by another session, Oracle throws an error immediately.
- Your code does not hang or block.

Use When:
- You want to fail fast if rows are locked
- You’re building user-facing transactions
- You want explicit error handling


```
DECLARE
  CURSOR emp_cur IS
    SELECT id FROM employees
    WHERE department_id = 10
    FOR UPDATE NOWAIT;
BEGIN
  FOR emp_rec IN emp_cur LOOP
    -- Try to update row
    UPDATE employees
    SET salary = salary + 100
    WHERE CURRENT OF emp_cur;
  END LOOP;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
```

### SKIP LOCKED: Just Move On
- Oracle skips over any locked rows silently
- Only returns rows that are not currently locked

Use When:
- Running parallel jobs that process the same table
- Performing chunked ETL updates or cleanups
- You want to avoid waiting or failing, and are okay skipping rows

```
DECLARE
  CURSOR emp_cur IS
    SELECT id FROM employees
    WHERE department_id = 20
    FOR UPDATE SKIP LOCKED;
BEGIN
  FOR emp_rec IN emp_cur LOOP
    -- This will only process rows not locked by other sessions
    UPDATE employees
    SET salary = salary + 500
    WHERE CURRENT OF emp_cur;
  END LOOP;
  COMMIT;
END;
```

### NOWAIT vs SKIP LOCKED

| Behavior            | Default  | `NOWAIT`                 | `SKIP LOCKED`            |
| ------------------- | -------- | ------------------------ | ------------------------ |
| Block on locked row | ✅ Yes    | ❌ No (raises error)      | ❌ No (skips the row)     |
| Error raised?       | ❌ No     | ✅ Yes (`ORA-00054`)      | ❌ No                     |
| Skips locked rows?  | ❌ No     | ❌ No                     | ✅ Yes                    |
| Use case            | Standard | User actions, quick fail | Batch jobs, parallel ETL |


### WHERE CURRENT OF
`WHERE CURRENT OF` is used with a cursor declared with `FOR UPDATE` to refer to the current row being fetched by that cursor. This eliminates the need to repeat primary key logic, and it’s safer and more efficient.


```
-- Instead of:
UPDATE employees SET ... WHERE id = emp_rec.id;

-- You use:

UPDATE employees SET ... WHERE CURRENT OF emp_cur;
```

```
CURSOR cur IS
  SELECT ... FROM table
  FOR UPDATE;

...

UPDATE table
SET ...
WHERE CURRENT OF cur;
```

#### Cursor + Row-by-Row Update

```
DECLARE
  CURSOR c IS SELECT * FROM orders WHERE status = 'PENDING' FOR UPDATE;
BEGIN
  FOR r IN c LOOP
    -- Mark the order as processed
    UPDATE orders SET status = 'PROCESSED'
    WHERE CURRENT OF c;
  END LOOP;
  COMMIT;
END;
```

## REF CURSOR
A REF CURSOR is a pointer to a result set that:
- Can be passed as a parameter to procedures/functions
- Is not tied to a specific query at compile time (can be dynamically opened at runtime)
- Supports returning rows from dynamic SQL

Think of a REF CURSOR like a database-friendly iterator, or a query handle.

### REF CURSOR vs Static Cursor

| Feature                        | Static Cursor | REF CURSOR          |
| ------------------------------ | ------------- | ------------------- |
| Fixed SQL                      | Yes           | No (can be dynamic) |
| Return from procedure          | No            | Yes                 |
| Pass as parameter              | No            | Yes                 |
| Reusable with multiple queries | No            | Yes                 |

### Declaring a Reference Coursor

You declare a REF CURSOR type, and then a variable of that type:

```
-- Declare a REF CURSOR type (can be weak or strong)
TYPE ref_cursor_type IS REF CURSOR;

-- Then declare a variable of that type
c_emps ref_cursor_type;
```

### Opening a REF CURSOR with a Query

```
OPEN c_emps FOR SELECT * FROM employees WHERE department_id = 10;
```

### Types of REF CURSORs: Strong vs Weak

- Use strong if you want compile-time checking.
- Use weak for general-purpose, dynamic logic (like APIs or reports).

| Type       | Description                                    | Example                               |
| ---------- | ---------------------------------------------- | ------------------------------------- |
| **Strong** | Cursor with a fixed return type (enforced)     | `REF CURSOR RETURN employees%ROWTYPE` |
| **Weak**   | No predefined return structure (more flexible) | `SYS_REFCURSOR`, `REF CURSOR`         |

### SYS_REFCURSOR (Oracle Built-In)
Oracle provides a predefined weak REF CURSOR called `SYS_REFCURSOR`. You can use it directly without declaring a new type.

```
DECLARE
  c SYS_REFCURSOR;
  v_name employees.name%TYPE;
BEGIN
  OPEN c FOR SELECT name FROM employees WHERE id < 105;

  LOOP
    FETCH c INTO v_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(v_name);
  END LOOP;

  CLOSE c;
END;
```
