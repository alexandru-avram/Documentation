# 06. Triggers

## Row-level BEFORE trigger
```sql
CREATE OR REPLACE FUNCTION audit.set_defaults()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.created_at IS NULL THEN
    NEW.created_at := now();
  END IF;
  RETURN NEW;
END $$;

CREATE TRIGGER set_defaults_bi
BEFORE INSERT ON public.orders
FOR EACH ROW
EXECUTE FUNCTION audit.set_defaults();
```

## Row-level AFTER trigger (log changes)
```sql
CREATE OR REPLACE FUNCTION audit.log_order_change()
RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO audit.order_log(order_id, action, at)
  VALUES (COALESCE(NEW.id, OLD.id),
          TG_OP,
          clock_timestamp());
  RETURN NULL; -- AFTER triggers can ignore return
END $$;

CREATE TRIGGER orders_aiud
AFTER INSERT OR UPDATE OR DELETE ON public.orders
FOR EACH ROW
EXECUTE FUNCTION audit.log_order_change();
```

## Statement-level with transition tables
```sql
CREATE OR REPLACE FUNCTION audit.bulk_insert_log()
RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO audit.bulk_event(table_name, inserted_rows)
  SELECT TG_TABLE_NAME, count(*) FROM new_rows;
  RETURN NULL;
END $$;

CREATE TRIGGER orders_after_insert_stmt
AFTER INSERT ON public.orders
REFERENCING NEW TABLE AS new_rows
FOR EACH STATEMENT
EXECUTE FUNCTION audit.bulk_insert_log();
```

### INSTEAD OF (for updatable views)
```sql
CREATE OR REPLACE FUNCTION vw_orders_upsert()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO orders(id, total) VALUES (NEW.id, NEW.total);
    RETURN NEW;
  END IF;
  RETURN NULL;
END $$;

CREATE TRIGGER vw_orders_ins
INSTEAD OF INSERT ON vw_orders
FOR EACH ROW EXECUTE FUNCTION vw_orders_upsert();
```

### Notes
- In row-level triggers, return **`NEW`** for INSERT/UPDATE, **`OLD`** for DELETE.
- Inspect context via `TG_OP`, `TG_TABLE_NAME`, `TG_WHEN`, etc.