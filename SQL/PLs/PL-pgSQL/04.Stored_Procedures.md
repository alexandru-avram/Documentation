# 04. Stored Procedures (`CALL`) â€” with transaction control

> PostgreSQL 11+ introduces **procedures** that can `COMMIT/ROLLBACK` inside the body.

## Basic procedure
```sql
CREATE OR REPLACE PROCEDURE maintenance.vacuum_one(tbl regclass)
LANGUAGE plpgsql
AS $$
BEGIN
  RAISE NOTICE 'Vacuuming %', tbl;
  EXECUTE format('VACUUM (VERBOSE, ANALYZE) %s', tbl);
END $$;

CALL maintenance.vacuum_one('public.orders');
```

## Transaction control example
> Call **outside** any explicit transaction (`CALL` starts its own context).

```sql
CREATE OR REPLACE PROCEDURE batch.apply_payments()
LANGUAGE plpgsql
AS $$
DECLARE r record;
BEGIN
  FOR r IN SELECT * FROM staging.payments LOOP
    BEGIN
      -- start a sub-transaction
      PERFORM pg_advisory_xact_lock(42);
      -- do work that might fail
      UPDATE accounts SET balance = balance - r.amount WHERE id = r.src_id;
      UPDATE accounts SET balance = balance + r.amount WHERE id = r.dst_id;
      -- commit the unit
      COMMIT;
      START TRANSACTION;
    EXCEPTION WHEN others THEN
      RAISE NOTICE 'skipping failed payment id=%', r.id;
      ROLLBACK;      -- discard failed unit
      START TRANSACTION;
    END;
  END LOOP;
  COMMIT;
END $$;
```
Notes:
- Use **procedures** when you need DDL or transaction demarcation inside the routine.
- Functions cannot issue `COMMIT/ROLLBACK`.

## IN/INOUT parameters
```sql
CREATE OR REPLACE PROCEDURE util.swap(INOUT a int, INOUT b int)
LANGUAGE plpgsql
AS $$
DECLARE tmp int;
BEGIN
  tmp := a; a := b; b := tmp;
END $$;

CALL util.swap(a => 10, b => 20);  -- returns via OUT params
```