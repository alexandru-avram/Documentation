# 03. Functions

## Anatomy
```sql
CREATE OR REPLACE FUNCTION sales.tax(p_amount numeric, p_rate numeric DEFAULT 0.19)
RETURNS numeric
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  RETURN round(p_amount * p_rate, 2);
END $$;
```

### Notes
- Parameter defaults allowed; call with named args: `SELECT sales.tax(p_rate => 0.2, p_amount => 100);`
- Volatility: `IMMUTABLE` (same inputs â†’ same output), `STABLE` (within statement), `VOLATILE` (default).
- Null handling: `RETURNS NULL ON NULL INPUT` (a.k.a. `STRICT`).

```sql
CREATE FUNCTION f_strict(a int) RETURNS int
LANGUAGE plpgsql STRICT AS $$ BEGIN RETURN a+1; END $$;
```

## Returning sets
### RETURNS SETOF
```sql
CREATE OR REPLACE FUNCTION top_customers(n int)
RETURNS SETOF customers
LANGUAGE plpgsql
ROWS 50
AS $$
BEGIN
  RETURN QUERY
  SELECT c.*
  FROM customers c
  ORDER BY c.total_spent DESC
  LIMIT n;
END $$;
```

### RETURNS TABLE
```sql
CREATE OR REPLACE FUNCTION orders_summary(min_date date)
RETURNS TABLE (cust_id int, cnt bigint, amt numeric)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT o.cust_id, count(*), sum(o.total)
  FROM orders o
  WHERE o.created_at >= min_date
  GROUP BY 1;
END $$;
```

## Security & schema hygiene
```sql
CREATE FUNCTION admin.do_sensitive(uid int)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, admin
AS $$ BEGIN /*...*/ END $$;

REVOKE ALL ON FUNCTION admin.do_sensitive(int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION admin.do_sensitive(int) TO app_role;
```

## Diagnostics
```sql
GET DIAGNOSTICS rows_affected = ROW_COUNT;
RAISE NOTICE 'affected=%', rows_affected;
```

## Dynamic SQL (values vs identifiers)
```sql
-- identifiers via format('%I', ...); values via USING
EXECUTE format('UPDATE %I SET active = $1 WHERE id = $2', target_table)
USING true, p_id;
```