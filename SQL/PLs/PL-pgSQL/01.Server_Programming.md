# 01. Server programming (PL/pgSQL runtime & posture)

> Goal: know how PL/pgSQL executes, how to set security/search path, and how to log & tune.

## 1) Language & enabling
- `plpgsql` is installed by default in modern PostgreSQL. Verify:
  ```sql
  SHOW plpgsql.enable_inlined;
  ```

## 2) Anonymous blocks for quick experiments
```sql
DO $$
DECLARE v int := 0;
BEGIN
  v := v + 1;
  RAISE NOTICE 'v=%', v;
END $$ LANGUAGE plpgsql;
```

## 3) Security model
- **Invoker** (default): runs with caller's privileges.
- **Definer**: `SECURITY DEFINER` runs with the function owner's privileges.
- Always **pin `search_path`** when using `SECURITY DEFINER` to avoid hijacking:
```sql
CREATE OR REPLACE FUNCTION admin.reset_user(uid int)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public   -- safest: avoid unsafe schemas
AS $$
BEGIN
  PERFORM 1; -- work
END $$;

REVOKE ALL ON FUNCTION admin.reset_user(int) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION admin.reset_user(int) TO app_role;
```

## 4) Controlling `search_path` and GUCs
- Prefer setting on the function:
```sql
CREATE FUNCTION f() RETURNS int
LANGUAGE plpgsql
SET search_path = public, pg_temp
SET work_mem = '64MB'
AS $$ BEGIN RETURN 1; END $$;
```
- Or at call-time: `SET LOCAL work_mem='64MB';` within a transaction.

## 5) Plan caching & dynamic SQL
- PL/pgSQL **caches plans** for static SQL (good for repeated calls).
- Use **`EXECUTE`** for dynamic identifiers/DDL or when plan depends on varying parameter types.
- **Never** concat values into SQLâ€”use `USING` to bind and `format()` for identifiers.
```sql
EXECUTE format('SELECT count(*) FROM %I WHERE id = $1', tbl)
INTO cnt
USING wanted_id; -- safe value binding
```

## 6) Logging & diagnostics
```sql
RAISE NOTICE 'rows=% time=% ms', rowcount, clock_timestamp();
RAISE WARNING 'unexpected state: %', state_var;
RAISE EXCEPTION USING MESSAGE = 'bad input', DETAIL = 'uid='||uid, HINT='check caller';
```
- Inspect error codes (SQLSTATE) in `EXCEPTION` blocks.

## 7) Performance posture
- Mark volatility correctly: `IMMUTABLE`, `STABLE`, or `VOLATILE` (default).
- For set-returning functions, set `ROWS` estimate:
```sql
CREATE FUNCTION top_n(n int) RETURNS SETOF int
LANGUAGE plpgsql
ROWS 100
AS $$ BEGIN RETURN; END $$;
```
- Avoid tight loops for heavy work; push set-logic into **SQL** when possible.

## 8) Testing helpers
- Wrap examples in `DO $$ ... $$`.
- Use `pgTAP` for unit tests if available.