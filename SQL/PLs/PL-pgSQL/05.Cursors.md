# 05. Cursors

## Prefer implicit cursors
```sql
FOR rec IN SELECT id, total FROM orders WHERE status = 'open' LOOP
  PERFORM process_order(rec.id);
END LOOP;
```

## Explicit cursor bound to a query
```sql
DO $$
DECLARE
  c CURSOR FOR SELECT id, total FROM orders ORDER BY id;
  r record;
BEGIN
  OPEN c;
  LOOP
    FETCH c INTO r;
    EXIT WHEN NOT FOUND;
    PERFORM process_order(r.id);
  END LOOP;
  CLOSE c;
END $$;
```

## `refcursor` pattern (returns a handle to the client)
```sql
CREATE OR REPLACE FUNCTION api.open_orders_cursor()
RETURNS refcursor
LANGUAGE plpgsql
AS $$
DECLARE cur refcursor;
BEGIN
  OPEN cur FOR SELECT * FROM orders WHERE status='open';
  RETURN cur;
END $$;

-- client usage:
BEGIN;
SELECT api.open_orders_cursor();      -- returns a cursor name
FETCH 50 FROM "<cursor_name>";
CLOSE "<cursor_name>";
COMMIT;
```

### Tips
- Use **`SCROLL`** if you need backward fetches: `OPEN c SCROLL FOR SELECT ...`.
- Cursor lifetime: a non-`WITH HOLD` cursor dies at transaction end.
- Often a **single SQL statement** (with `LIMIT/OFFSET`) beats cursor complexity.