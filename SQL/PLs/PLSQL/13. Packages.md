# Packages
A package is a container of related PL/SQL elements, bundled into two parts:

| Part                      | Description                                                                |
| ------------------------- | -------------------------------------------------------------------------- |
| **Package Specification** | The **interface**: declares public types, procedures, functions, variables |
| **Package Body**          | The **implementation**: contains the actual code for declared items        |

Packages promote encapsulation, modularity, and reuse.

| Benefit                 | Description                                                             |
| ----------------------- | ----------------------------------------------------------------------- |
| **Modularity**          | Group related logic together (e.g., payroll\_pkg, audit\_pkg)           |
| **Encapsulation**       | Hide internal procedures, expose only public ones                       |
| **Reusability**         | Centralize common logic (validation, calculations)                      |
| **Performance**         | Loaded into memory once per session (all objects in package accessible) |
| **Overloading Support** | Allow multiple subprograms with same name, different parameters         |
| **Global Variables**    | Shared session-level state (via package-level variables)                |

## Objects that can be declared
| Object Type                                        | Can Declare in Package?  |
| -------------------------------------------------- | ------------------------ |
| ✅ **Procedures**                                   | ✅ Yes                    |
| ✅ **Functions**                                    | ✅ Yes                    |
| ✅ **Variables / Constants**                        | ✅ Yes                    |
| ✅ **Cursors (Explicit)**                           | ✅ Yes                    |
| ✅ **User-Defined Types** (`RECORD`, `TABLE`, etc.) | ✅ Yes                    |
| ✅ **Exception declarations**                       | ✅ Yes                    |
| ✅ **Collections (Nested Table, VARRAY)**           | ✅ Yes                    |
| ✅ **REF CURSOR types**                             | ✅ Yes                    |
| ✅ **Forward declarations**                         | ✅ Yes (in spec)          |
| ✅ **Initialization block**                         | ✅ Yes (in **body only**) |
| ✅ **Overloaded procedures/functions**              | ✅ Yes                    |

| ❌ Object Type                                    | Can Declare in Package?                                    | Notes                                   |
| ------------------------------------------------ | ---------------------------------------------------------- | --------------------------------------- |
| ❌ **Triggers**                                   | ❌ No                                                       | Must be defined separately              |
| ❌ **Standalone anonymous blocks**                | ❌ No                                                       | Must run independently in a session     |
| ❌ **DML Statements (`INSERT`, `UPDATE`, etc.)**  | ❌ No (but can be inside procedures/functions)              |                                         |
| ❌ **DDL Statements (`CREATE`, `DROP`, etc.)**    | ❌ No (same as above)                                       |                                         |
| ❌ **Cursors for dynamic SQL (`DBMS_SQL`)**       | ❌ No direct declaration, but can be used inside procedures |                                         |
| ❌ **Package within a package (nested packages)** | ❌ No                                                       | PL/SQL does not support nested packages |



## Creating Packages

### Package Specification — defines the public interface

```
CREATE OR REPLACE PACKAGE payroll_pkg IS
  -- Constants
  bonus_rate CONSTANT NUMBER := 0.10;

  -- Public procedures/functions
  PROCEDURE add_employee(p_name VARCHAR2, p_salary NUMBER);
  FUNCTION get_bonus(p_salary NUMBER) RETURN NUMBER;

  -- Public variable
  v_last_emp_id NUMBER;

END payroll_pkg;
```

### Package Body — contains the implementation logic

```
CREATE OR REPLACE PACKAGE BODY payroll_pkg IS

  PROCEDURE add_employee(p_name VARCHAR2, p_salary NUMBER) IS
  BEGIN
    INSERT INTO employees(name, salary)
    VALUES (p_name, p_salary);

    SELECT MAX(id) INTO v_last_emp_id FROM employees;
  END;

  FUNCTION get_bonus(p_salary NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN p_salary * bonus_rate;
  END;

END payroll_pkg;
```

## Package Initialization
A package body can include an optional initialization section — a block that runs once per session, the first time the package is referenced.

 Initialization block is ideal for:
- Preloading data
- Setting up session-specific flags
- Logging load time for debugging

```
CREATE OR REPLACE PACKAGE BODY example_pkg IS

  v_loaded_date DATE;

  PROCEDURE say_hello IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello from package');
  END;

BEGIN  -- Initialization block
  v_loaded_date := SYSDATE;
  DBMS_OUTPUT.PUT_LINE('example_pkg loaded at: ' || v_loaded_date);
END;
```

### Using Collections in Packages

You can declare collection types in the package specification and use them anywhere in the app.

```
CREATE OR REPLACE PACKAGE hr_pkg IS
  TYPE salary_list IS TABLE OF NUMBER;
  v_salaries salary_list := salary_list();

  PROCEDURE load_salaries(p_dept_id NUMBER);
  PROCEDURE print_salaries;
END;


----

CREATE OR REPLACE PACKAGE BODY hr_pkg IS

  PROCEDURE load_salaries(p_dept_id NUMBER) IS
  BEGIN
    SELECT salary
    BULK COLLECT INTO v_salaries
    FROM employees
    WHERE department_id = p_dept_id;
  END;

  PROCEDURE print_salaries IS
  BEGIN
    FOR i IN 1..v_salaries.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salaries(i));
    END LOOP;
  END;

END;

----- CALLING

BEGIN
  hr_pkg.load_salaries(10);
  hr_pkg.print_salaries;
END;
```

## Stateful vs Stateless Package Behavior
In PL/SQL, state refers to the values stored in memory between calls to procedures/functions in the same user session.

When you use package-level variables, that data is retained for the duration of the session — and that's what we call stateful behavior.

| Feature                  | Stateful Package                  | Stateless Package                   |
| ------------------------ | --------------------------------- | ----------------------------------- |
| Retains variable values? | ✅ Yes                             | ❌ No                                |
| Session-scoped memory    | ✅ Yes                             | ❌ No                                |
| Good for caching/session | ✅ Yes                             | ❌ Not applicable                    |
| Good for scalability     | ❌ Risk of memory bloat or leaks   | ✅ Yes (safer in multi-user systems) |
| Usage example            | Session counters, temporary flags | Math logic, APIs, pure functions    |


### Stateful Packages
A stateful package maintains values between calls in the same session.

This is possible when:
- You define variables in the package spec or body
- You do not reset or reinitialize them after use

```
CREATE OR REPLACE PACKAGE session_counter_pkg IS
  PROCEDURE increment_counter;
  PROCEDURE show_counter;
END;

-----

CREATE OR REPLACE PACKAGE BODY session_counter_pkg IS
  -- This variable holds its value between calls
  v_counter NUMBER := 0;

  PROCEDURE increment_counter IS
  BEGIN
    v_counter := v_counter + 1;
  END;

  PROCEDURE show_counter IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Current counter: ' || v_counter);
  END;
END;

-----

BEGIN
  session_counter_pkg.increment_counter;
  session_counter_pkg.increment_counter;
  session_counter_pkg.show_counter; -- Output: 2
END;
```

If you run this in the same session again, `v_counter` will keep growing.


### Stateless Packages
A stateless package does not preserve state between calls. Each invocation:
- Does not remember variables
- Acts as if it's running "fresh" each time

Why Are Some Packages Stateless?
- They don’t use global variables
- Or they reset their state each time via local variables or v_var := NULL;
- Stateless design is preferred for scalability and thread safety in multi-user systems

```
CREATE OR REPLACE PACKAGE math_pkg IS
  FUNCTION add(x NUMBER, y NUMBER) RETURN NUMBER;
END;

-----

CREATE OR REPLACE PACKAGE BODY math_pkg IS
  FUNCTION add(x NUMBER, y NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN x + y;
  END;
END;
```
This function is stateless — no values are stored between calls.


### Use Cases
| Use Case                            | Stateful? | Why                  |
| ----------------------------------- | --------- | -------------------- |
| Track number of edits in session    | ✅ Yes     | Use package variable |
| Perform calculations with no memory | ❌ No      | Safer, repeatable    |
| Cache exchange rates for 1 session  | ✅ Yes     | Performance boost    |
| Process bulk data statelessly       | ❌ No      | Avoid memory bloat   |


## Oracle Supplied Packages (Built-in)

```
| Package                    | Purpose                                      |
| -------------------------- | -------------------------------------------- |
| `DBMS_OUTPUT`              | Display text in PL/SQL (for debugging)       |
| `DBMS_SQL`                 | Execute dynamic SQL (very low-level control) |
| `UTL_FILE`                 | Read/write files on the server filesystem    |
| `DBMS_LOB`                 | Work with BLOB, CLOB data                    |
| `DBMS_RANDOM`              | Generate random numbers/strings              |
| `DBMS_UTILITY`             | General system utilities                     |
| `DBMS_METADATA`            | Extract DDL from database objects            |
| `DBMS_SCHEDULER`           | Schedule and manage jobs                     |
| `UTL_MAIL`, `UTL_SMTP`     | Send emails from the database                |
| `DBMS_ALERT` / `DBMS_PIPE` | Communicate between sessions asynchronously  |
```
