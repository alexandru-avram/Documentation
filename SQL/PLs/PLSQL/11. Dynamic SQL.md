# Dynamic SQL

Dynamic SQL is SQL code that is constructed and executed at runtime — rather than being hardcoded at compile-time.

You use it when:
- The table or column name is unknown until runtime
- The `WHERE` clause is variable
- You need to execute DDL (like `CREATE`, `DROP`)
- You're building generic procedures (e.g., universal data loaders)

PL/SQL supports two dynamic SQL methods using:
| Method              | Best For                                                        |
| ------------------- | --------------------------------------------------------------- |
| `EXECUTE IMMEDIATE` | Most use cases (DML, DDL, SELECT INTO, anonymous blocks)        |
| `DBMS_SQL`          | Very dynamic or generic cases (unknown number/types of columns) |

| Technique            | Use Case                              | Supports Bind? | Use With Loops?    |
| -------------------- | ------------------------------------- | -------------- | ------------------ |
| `EXECUTE IMMEDIATE`  | General-purpose DDL/DML/SELECT        | ✅ Yes          | ❌ (no cursor loop) |
| `DBMS_SQL`           | Fully dynamic queries w/ unknown cols | ✅ Yes          | ✅ Yes              |
| `OPEN-FOR` + `FETCH` | Dynamic cursor result sets            | ✅ Yes          | ✅ Yes              |
| `BULK COLLECT`       | Fetch many rows at once               | ✅ Yes          | ✅ (with FOR loop)  |

## EXECUTE IMMEDIATE
EXECUTE IMMEDIATE is the easiest and most common way to run dynamic SQL in PL/SQL.

It supports:
- DML (`INSERT`, `UPDATE`, `DELETE`)
- DDL (`CREATE`, `DROP`, etc.)
- `SELECT INTO` queries
- Anonymous PL/SQL blocks

```
EXECUTE IMMEDIATE dynamic_string;
```

### With variable binding:
Always use USING with bind variables to prevent SQL injection!

```
EXECUTE IMMEDIATE dynamic_string USING bind_variable;
```

```
DECLARE
  v_sql VARCHAR2(200);
  v_id  NUMBER := 101;
BEGIN
  v_sql := 'DELETE FROM employees WHERE id = :1';
  EXECUTE IMMEDIATE v_sql USING v_id;
END;
```

### Without variable binding:

```
EXECUTE IMMEDIATE dynamic_string INTO out_var USING in_var;
```

### SELECT INTO Dynamically

```
DECLARE
  v_sql   VARCHAR2(100);
  v_name  VARCHAR2(50);
BEGIN
  v_sql := 'SELECT name FROM employees WHERE id = :1';
  EXECUTE IMMEDIATE v_sql INTO v_name USING 101;
  DBMS_OUTPUT.PUT_LINE('Name = ' || v_name);
END;
```

## DBMS_SQL (Advanced Dynamic SQL)
`DBMS_SQL` is a low-level package that gives full control over dynamic SQL:
- Use when you don’t know column names/types at compile-time
- Supports dynamic column definitions
- Can be used to parse, describe, bind, define, fetch, and close statements

Use when:
- You don’t know columns or number of columns at compile-time
- You want to describe or loop through columns dynamically
- You’re building generic tools (e.g., ETL frameworks)

Baisc flow:
```
v_cursor := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(v_cursor, dynamic_sql, DBMS_SQL.NATIVE);
DBMS_SQL.DEFINE_COLUMN(v_cursor, position, datatype);
DBMS_SQL.EXECUTE(v_cursor);
DBMS_SQL.FETCH_ROWS(v_cursor);
DBMS_SQL.COLUMN_VALUE(v_cursor, position, variable);
DBMS_SQL.CLOSE_CURSOR(v_cursor);
```

```
DECLARE
  v_cursor  INTEGER;
  v_sql     VARCHAR2(100) := 'SELECT name FROM employees WHERE id = :id';
  v_name    VARCHAR2(100);
  rows_fetched INTEGER;
BEGIN
  v_cursor := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(v_cursor, v_sql, DBMS_SQL.NATIVE);

  DBMS_SQL.BIND_VARIABLE(v_cursor, ':id', 101);
  DBMS_SQL.DEFINE_COLUMN(v_cursor, 1, v_name, 100);

  rows_fetched := DBMS_SQL.EXECUTE(v_cursor);

  IF DBMS_SQL.FETCH_ROWS(v_cursor) > 0 THEN
    DBMS_SQL.COLUMN_VALUE(v_cursor, 1, v_name);
    DBMS_OUTPUT.PUT_LINE('Name = ' || v_name);
  END IF;

  DBMS_SQL.CLOSE_CURSOR(v_cursor);
END;
```

## OPEN-FOR + FETCH

`OPEN cursor_variable FOR dynamic_sql_string` allows you to open a REF CURSOR with a dynamic or static query.

It’s used when you want to:
- Pass different queries to the same cursor variable
- Return result sets from procedures/functions
- Build flexible APIs or reporting tools

Once opened, the REF CURSOR behaves like a regular cursor — you can `FETCH`, loop, and `CLOSE` it.


```
TYPE ref_cursor IS REF CURSOR;
c ref_cursor;

OPEN c FOR 'SELECT ... FROM ... WHERE ...';
FETCH c INTO var1, var2, ...;
CLOSE c;
```

```
DECLARE
  TYPE emp_cursor IS REF CURSOR;
  c_emp emp_cursor;

  v_name employees.name%TYPE;
  v_salary employees.salary%TYPE;

BEGIN
  -- Open the REF CURSOR dynamically with a query
  OPEN c_emp FOR
    SELECT name, salary FROM employees WHERE department_id = 10;

  -- Fetch rows one by one using FETCH
  LOOP
    FETCH c_emp INTO v_name, v_salary;
    EXIT WHEN c_emp%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE('Name: ' || v_name || ', Salary: ' || v_salary);
  END LOOP;

  -- Close the cursor to release memory
  CLOSE c_emp;
END;
```


| Benefit                 | Description                         |
| ----------------------- | ----------------------------------- |
| ✅ Flexibility           | Choose query dynamically at runtime |
| ✅ Reusability           | One cursor type, many queries       |
| ✅ Row-by-row control    | Perfect for conditional row logic   |
| ✅ Bind variable support | Prevents SQL injection              |

| Use Case                     | Example                                  |
| ---------------------------- | ---------------------------------------- |
| Dynamic reporting            | Build a query based on user filters      |
| Reusable data-fetching logic | Procedure returns different SELECTs      |
| Pagination                   | Fetch rows conditionally by LIMIT/OFFSET |
| Multi-entity access          | Fetch from different tables dynamically  |

| Tip                                    | Why It Matters                     |
| -------------------------------------- | ---------------------------------- |
| Always `CLOSE` REF CURSORs             | Avoid session memory leaks         |
| Use `%NOTFOUND` after `FETCH`          | Prevent infinite loops             |
| Prefer `%ROWTYPE` for full-row queries | Easier to maintain                 |
| Use `USING` with `OPEN-FOR` for safety | Prevent SQL injection & hardcoding |

| Concept     | Description                                      |
| ----------- | ------------------------------------------------ |
| `OPEN-FOR`  | Dynamically opens a REF CURSOR with a SQL string |
| `FETCH`     | Retrieves one row at a time from the open cursor |
| `USING`     | Passes bind values safely to dynamic queries     |
| `%NOTFOUND` | Used to exit loop when cursor is exhausted       |
| `%ROWTYPE`  | Simplifies row fetching                          |

If you're selecting all columns, using `%ROWTYPE` is cleaner:
```
DECLARE
  TYPE emp_cursor IS REF CURSOR;
  c_emp emp_cursor;

  v_emp employees%ROWTYPE;
BEGIN
  OPEN c_emp FOR
    SELECT * FROM employees WHERE department_id = 20;

  LOOP
    FETCH c_emp INTO v_emp;
    EXIT WHEN c_emp%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE(v_emp.id || ': ' || v_emp.name);
  END LOOP;

  CLOSE c_emp;
END;
```

`USING` binds values at runtime, just like `EXECUTE IMMEDIATE`.
```
DECLARE
  TYPE dept_cursor IS REF CURSOR;
  c_dept dept_cursor;

  v_name employees.name%TYPE;
BEGIN
  OPEN c_dept FOR
    'SELECT name FROM employees WHERE department_id = :1'
    USING 30;

  LOOP
    FETCH c_dept INTO v_name;
    EXIT WHEN c_dept%NOTFOUND;

    DBMS_OUTPUT.PUT_LINE(v_name);
  END LOOP;

  CLOSE c_dept;
END;
```

## BULK COLLECT
`BULK COLLECT` allows you to fetch multiple rows at once into a collection — great for performance.

```
EXECUTE IMMEDIATE dynamic_sql BULK COLLECT INTO collection_variable;
```

`BULK COLLECT` is ideal for processing large result sets efficiently.

```
DECLARE
  TYPE name_list IS TABLE OF employees.name%TYPE;
  v_names name_list;

  v_sql VARCHAR2(200) := 'SELECT name FROM employees WHERE department_id = :1';
BEGIN
  EXECUTE IMMEDIATE v_sql BULK COLLECT INTO v_names USING 10;

  FOR i IN 1..v_names.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE(v_names(i));
  END LOOP;
END;
```
