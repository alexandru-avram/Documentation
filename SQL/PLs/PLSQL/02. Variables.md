# Variables

A variable in PL/SQL is a named storage location that temporarily holds a value during program execution. You use variables to store data, manipulate it, and pass it between blocks, procedures, and functions.

## Variable Scope
Scope defines where a variable can be accessed:

Scope	Description	Example
* **Local** : 	Declared inside a block or sub-block,	accessible only in that block
* **Global (in packages)** :	Declared in a package specification, accessible across program units

## Naming Rules & Conventions
Variables have a set of rules:
* Must start with a letter
* Can contain only some special characters
* Can be maximum 30 characters
* Are not an Oracle reserved word (example: `select`)

Naming convention:
* **VARIABLE** -> v_varialbe_name
* **CURSOR** -> cur_cursor_name
* **EXCEPTION** -> e_exception_name
* **PROCEDURE** -> p_procedure_name
* **BIND VARIABLE** -> b_bind_name

## Declaring and Initializing
A variable can be declared in the `DECLARE` section of the PL/SQL script.

```
variable_name [CONSTANT] datatype [NOT NULL] [:= DEFAULT value|expression];
```

* variable_name — the name you choose (must follow naming rules)
* [CONSTANT] — determine that the variable will be a constant
* datatype — the type of data it will hold (e.g., NUMBER, VARCHAR2)
* [NOT NULL] — optional constraint to disallow NULLs (requires initialization)
* [DEFAULT value|expression] — optional initial value

Example:
```
DECLARE
  v_text VARCHAR2(50); -- Simple text variable
  v_numb NUMBER(5,2) NOT NULL -- Number varialbe, cannot be null
  v_full_name VARCHAR2(100) NOT NULL := 'John Doe' -- Text variable that has the default value of John Doe
  v_company_name [CONSTANT] VARCHAR2(100) := 'ACME SRL' -- Constant, cannot be changed later
```

You can also assign or modify variable values later inside the BEGIN block.

```
DECLARE
  v_name VARCHAR2(50);
BEGIN
  v_name := 'John Doe'; -- Assigned inside BEGIN
  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
END;
```

If you declare a variable as `NOT NULL`, you must initialize it immediately. Otherwise, Oracle will throw a compilation error: *"PLS-00218: a variable declared NOT NULL must have an initialization assignment"*

```
DECLARE
  v_department VARCHAR2(30) NOT NULL := 'Sales';  -- MUST be initialized
BEGIN
  NULL;
END;
```

## Special declaration
`%TYPE` and `%ROWTYPE` are two power tools in PL/SQL.

### %TYPE - Match the Type of a Column or Another Variable
* Declare a variable with the same datatype as a table column or another already-declared variable.
* If the column's datatype changes later (e.g., VARCHAR2(100) → VARCHAR2(200)), your code still works without modification!

```
variable_name table_name.column_name%TYPE;
```

In the following example, `v_employee_name` will have the same type as `employees.name`.

```
DECLARE
  v_employee_name employees.name%TYPE;
BEGIN
  SELECT name INTO v_employee_name
  FROM employees
  WHERE id = 101;

  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_name);
END;
```

### %ROWTYPE — Match the Structure of a Full Table Row
* Declare a variable that can hold an entire row from a table or cursor.
* Every column from the table is available as a field in the variable.

`%ROWTYPE` takes all columns — even ones you may not use (could be slightly inefficient for very wide tables if you don't need all data). If you need only a few fields, `%TYPE` on individual columns may be better.

```
record_name table_name%ROWTYPE;
record_name2 cursor_name%ROWTYPE;
```

`v_employee_record` can hold all columns from the `employees` table.
```
DECLARE
  v_employee_record employees%ROWTYPE;
BEGIN
  SELECT * INTO v_employee_record
  FROM employees
  WHERE id = 101;

  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_record.name);
  DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || v_employee_record.salary);
END;
```

Great when working with *explicit cursors*!
```
DECLARE
  CURSOR emp_cursor IS
    SELECT id, name, salary FROM employees;

  v_emp_rec emp_cursor%ROWTYPE;
BEGIN
  OPEN emp_cursor;
  FETCH emp_cursor INTO v_emp_rec;

  DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp_rec.name);
  CLOSE emp_cursor;
END;
```

## Bind variables
Bind variables are placeholders used to represent actual values that are passed into SQL statements at runtime. They bind your PL/SQL program to SQL queries. Instead of "hardcoding" values, you bind a value at execution time.

* **Performance**	Helps Oracle reuse execution plans, avoiding repeated parsing.
* **Security**	Helps prevent SQL injection attacks.
* **Flexibility**	Makes code dynamic and easier to reuse.

```
-- Instead of

SELECT * FROM employees WHERE id = 101;

-- Using a bind variable

SELECT * FROM employees WHERE id = :id_value;
```

Inside PL/SQL code, bind variables are usually ordinary variables you declare in the `DECLARE` section. Here, `v_id` acts like a bind variable inside the SQL statement

```
DECLARE
  v_id NUMBER := 101;
  v_name employees.name%TYPE;
BEGIN
  SELECT name INTO v_name
  FROM employees
  WHERE id = v_id;

  DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
END;
```

When using SQL*Plus or similar, bind variables are explicitly declared using `VARIABLE`:

```
VARIABLE v_name VARCHAR2(100);

BEGIN
  SELECT name INTO :v_name
  FROM employees
  WHERE id = 101;
END;
/

PRINT v_name;
```
