# Composite Data Types

A composite data type is a data structure that can hold multiple values (unlike scalar types like NUMBER or VARCHAR2 that hold only one value). They're extremely useful for:
* Grouping related data
* Returning or storing rows
* Working with collections of items (like arrays or tables)

PL/SQL Has 2 Main Composite Types:
* **RECORD** -	Group of fields (like a row)	*A row in a table*
* **COLLECTIONS** - Single variable that can hold multiple values * An array, or a table*


| Type              | Sparse? | Bounded? | Use Case Example                     |
| ----------------- | ------- | -------- | ------------------------------------ |
| RECORD            | No      | No       | Single-row data like a table row     |
| Associative Array | Yes     | No       | Caching lookup data by ID or name    |
| Nested Table      | Yes     | No       | Collections from SELECT INTO         |
| VARRAY            | No      | Yes      | Fixed-length lists like top 5 grades |



## RECORD

A `RECORD` in PL/SQL is a composite variable that groups multiple related values (called fields), similar to:
* A row in a table
* A struct in C
* An object without methods

Each field can have a different data type, and you access them using dot notation (`record_name.field_name`).

### Declaring a RECORD

#### %ROWTYPE
This automatically creates a RECORD that matches the structure of a table or view.

```
DECLARE
  v_emp employees%ROWTYPE;
BEGIN
  SELECT * INTO v_emp FROM employees WHERE id = 101;
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp.name || ', Salary: ' || v_emp.salary);
END;
```

#### TYPE ... IS RECORD (Custom Definition)
Gives you full control over the structure and fields.

```
DECLARE
  TYPE employee_rec IS RECORD (
    emp_id     NUMBER,
    emp_name   VARCHAR2(100),
    hire_date  DATE
  );

  emp_data employee_rec; -- variable of record type
BEGIN
  emp_data.emp_id := 101;
  emp_data.emp_name := 'John Doe';
  emp_data.hire_date := SYSDATE;

  DBMS_OUTPUT.PUT_LINE('ID: ' || emp_data.emp_id);
  DBMS_OUTPUT.PUT_LINE('Name: ' || emp_data.emp_name);
  DBMS_OUTPUT.PUT_LINE('Hire Date: ' || emp_data.hire_date);
END;
```

OUTPUT:
```
ID: 101
Name: John Doe
Hire Date: 13-MAY-25
```

### Accessing RECORD Fields
You access each field using dot notation:

```
v_emp.name := 'Maria';
DBMS_OUTPUT.PUT_LINE(v_emp.name);
```

### Using RECORDs in SELECT INTO

```
DECLARE
  v_emp employees%ROWTYPE;
BEGIN
  SELECT * INTO v_emp
  FROM employees
  WHERE id = 101;

  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_emp.salary);
END;
```

### RECORDs in Loops (Cursor FOR Loop)
A powerful use case: process query results row-by-row.

```
FOR emp_rec IN (SELECT id, name FROM employees) LOOP
  DBMS_OUTPUT.PUT_LINE('ID: ' || emp_rec.id || ', Name: ' || emp_rec.name);
END LOOP;
```

### RECORDs in Procedures and Functions
You can pass records as IN, OUT, or IN OUT parameters.

```
PROCEDURE show_employee(p_emp IN employees%ROWTYPE) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Name: ' || p_emp.name);
END;
```

### Nested RECORDs (Advanced)
You can nest one record inside another:

```
DECLARE
  TYPE address_type IS RECORD (
    city VARCHAR2(50),
    zip  VARCHAR2(10)
  );

  TYPE person_type IS RECORD (
    name VARCHAR2(100),
    address address_type
  );

  v_person person_type;
BEGIN
  v_person.name := 'Alex';
  v_person.address.city := 'Iasi';
  v_person.address.zip := '700000';

  DBMS_OUTPUT.PUT_LINE(v_person.name || ' lives in ' || v_person.address.city);
END;
```


## COLLECTIONS

A collection is a single variable that can hold multiple values, like an array or list.

PL/SQL supports three types of collections:

| Collection Type                    | Description                     | Indexed By        | Size Bound? | Persist in SQL? |
| ---------------------------------- | ------------------------------- | ----------------- | ----------- | --------------- |
| **Associative Array** (`INDEX BY`) | Key-value pair (sparse)         | Integer or String | No          | No              |
| **Nested Table**                   | Unbounded array (can have gaps) | Integer           | No          | Yes (as column) |
| **VARRAY**                         | Ordered, fixed-size array       | Integer           | Yes         | Yes             |

### Associative Arrays (INDEX BY Tables)
Also called index-by tables, they're sparse, unbounded, and perfect for dynamic, memory-based lookups.

Associative arrays are sets of key-value pairs. They can store data using a primary key value as the index, where the key values are not necessarily sequential. Associative arrays are also known as INDEX BY tables.

Associative arrays have only two columns, neither of which can be named:
- The first column, of integer or string type, acts as the primary key.
- The second column, of scalar or record data type, holds values

```
DECLARE
  TYPE emp_names_type IS TABLE OF VARCHAR2(100)
    INDEX BY PLS_INTEGER; -- or VARCHAR2(30)

  emp_names emp_names_type;
BEGIN
  emp_names(1) := 'Alice';
  emp_names(2) := 'Bob';

  DBMS_OUTPUT.PUT_LINE('First employee: ' || emp_names(1));
  DBMS_OUTPUT.PUT_LINE('Second employee: ' || emp_names(2));
END;
```

OUTPUT:
```
First employee: Alice
Second employee: Bob
```

[Example](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/Associative%20Arrays.sql)

### Nested Tables
Think of it as an unbounded array that can be used in both PL/SQL and database columns. Can be extended, deleted, truncated, and even stored in a table column as a collection.

```
DECLARE
  TYPE number_table IS TABLE OF NUMBER;

  nums number_table := number_table(10, 20, 30); -- constructor
BEGIN
  nums.DELETE(2); -- remove second element

  FOR i IN 1 .. nums.COUNT LOOP
    IF nums.EXISTS(i) THEN
      DBMS_OUTPUT.PUT_LINE('Element ' || i || ': ' || nums(i));
    END IF;
  END LOOP;
END;
```

OUTPUT:
```
DECLARE
  TYPE number_table IS TABLE OF NUMBER;

  nums number_table := number_table(10, 20, 30); -- constructor
BEGIN
  nums.DELETE(2); -- remove second element

  FOR i IN 1 .. nums.COUNT LOOP
    IF nums.EXISTS(i) THEN
      DBMS_OUTPUT.PUT_LINE('Element ' || i || ': ' || nums(i));
    END IF;
  END LOOP;
END;
```

OUTPUT:
```
Element 1: 10
Element 3: 30
```

[Example](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/Nested%20Tables.sql)

### VARRAY (Variable-Size Arrays)
Like nested tables, but with a fixed maximum size. When you define a VARRAY, you must declare the maximum size upfront. Stored in order and ideal when you need compact, bounded arrays.

Key Characteristics:
- Ordered (you access elements by index)
- Has a maximum number of elements (VARRAY(n))
- Stored as a single object (compact and efficient)
- Can be persisted in tables

```
DECLARE
  TYPE grades_type IS VARRAY(5) OF NUMBER;

  student_grades grades_type := grades_type(88, 92, 75);
BEGIN
  FOR i IN 1 .. student_grades.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Grade ' || i || ': ' || student_grades(i));
  END LOOP;
END;
```

OUTPUT:
```
Grade 1: 88
Grade 2: 92
Grade 3: 75
```

[Example VARRAY](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/VARRAYS.sql)

## Collection Methods (Shared Across Types)

| Method      | Description                                          | Applicable To                |
| ----------- | ---------------------------------------------------- | ---------------------------- |
| `COUNT`     | Returns the **number of elements** in the collection | All collections              |
| `EXISTS(i)` | Checks if **element at index `i` exists**            | All collections              |
| `FIRST`     | Returns **lowest index** currently defined           | All collections              |
| `LAST`      | Returns **highest index** currently defined          | All collections              |
| `PRIOR(i)`  | Returns **previous defined index** before `i`        | All collections              |
| `NEXT(i)`   | Returns **next defined index** after `i`             | All collections              |
| `DELETE`    | Deletes elements (single or all)                     | Nested tables, Assoc. arrays |
| `TRIM`      | Removes elements from **end** of collection          | Nested tables, VARRAYs       |
| `EXTEND`    | Adds empty elements to **end** of collection         | Nested tables, VARRAYs       |


| Method   | Assoc. Array | Nested Table | VARRAY |
| -------- | ------------ | ------------ | ------ |
| `COUNT`  | ✅            | ✅            | ✅      |
| `EXISTS` | ✅            | ✅            | ✅      |
| `FIRST`  | ✅            | ✅            | ✅      |
| `LAST`   | ✅            | ✅            | ✅      |
| `PRIOR`  | ✅            | ✅            | ✅      |
| `NEXT`   | ✅            | ✅            | ✅      |
| `DELETE` | ✅            | ✅            | ❌      |
| `TRIM`   | ❌            | ✅            | ✅      |
| `EXTEND` | ❌            | ✅            | ✅      |



### COUNT

```
v_list.COUNT;
```


```
DECLARE
  TYPE numlist IS TABLE OF NUMBER;
  v_nums numlist := numlist(10, 20, 30);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Count = ' || v_nums.COUNT);  -- Output: 3
END;
```

### EXISTS(i)
Returns TRUE if the index `i` is defined in the collection.

```
IF v_list.EXISTS(3) THEN ...
```

```
IF v_nums.EXISTS(5) THEN
  DBMS_OUTPUT.PUT_LINE('Index 5 exists!');
ELSE
  DBMS_OUTPUT.PUT_LINE('Index 5 does not exist.');
END IF;
```

### FIRST / LAST
Returns the first or last index value in the collection (not the value itself).

```
v_list.FIRST;  -- often 1
v_list.LAST;   -- depends on collection size
```

```
DBMS_OUTPUT.PUT_LINE('First index: ' || v_nums.FIRST);
DBMS_OUTPUT.PUT_LINE('Last index: ' || v_nums.LAST);
```

### PRIOR(i) / NEXT(i)
Get previous or next existing index relative to `i`.

```
v_list.PRIOR(3);  -- returns 2
v_list.NEXT(3);   -- returns 4
```

### DELETE
Removes elements from the collection. Not allowed on VARRAYs.

Variants:
* `DELETE` → removes all elements
* `DELETE(i)` → removes only index `i`
* `DELETE(i, j)` → removes a range

```
v_nums.DELETE(2);      -- Delete only index 2
v_nums.DELETE(1, 3);   -- Delete indexes 1 to 3
v_nums.DELETE;         -- Delete all elements
```

### TRIM
Removes elements from the end of the collection. Not allowed on associative arrays.

Variants:
* `TRIM;` → removes last element
* `TRIM(n);` → removes last `n` elements

```
v_nums.TRIM;       -- Removes last element
v_nums.TRIM(2);    -- Removes last 2 elements
```

### EXTEND
Adds empty elements to the end of a collection. Not for associative arrays.

Variants:
* `EXTEND;` → adds one null element
* `EXTEND(n);` → adds n elements
* `EXTEND(n, i);` → adds n copies of element at index `i`

```
v_nums.EXTEND(2);  -- Add 2 empty elements
v_nums(4) := 100;
v_nums.EXTEND(1, 4);  -- Copy value from index 4
```

### Real-World Example: Looping with FIRST/NEXT


```
DECLARE
  -- Declare an associative array mapping integer keys to employee names
  TYPE emp_map IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
  v_employees emp_map;

  -- Declare a loop variable
  i PLS_INTEGER;
BEGIN
  -- Assign values to specific indexes (sparse keys: 1, 3, 5)
  v_employees(1) := 'Alex';
  v_employees(3) := 'Maria';
  v_employees(5) := 'John';

  -- Initialize loop with the FIRST defined index
  i := v_employees.FIRST;

  -- Loop while there's a valid index
  WHILE i IS NOT NULL LOOP
    -- Output the current index and its associated value
    DBMS_OUTPUT.PUT_LINE('[' || i || '] ' || v_employees(i));

    -- Move to the next defined index
    i := v_employees.NEXT(i);
  END LOOP;
END;
```
