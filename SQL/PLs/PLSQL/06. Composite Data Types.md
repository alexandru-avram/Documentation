# Composite Data Types

A composite data type is a data structure that can hold multiple values (unlike scalar types like NUMBER or VARCHAR2 that hold only one value). They're extremely useful for:
* Grouping related data
* Returning or storing rows
* Working with collections of items (like arrays or tables)

PL/SQL Has 3 Main Composite Types:
* **RECORD** -	Group of fields (like a row)	*A row in a table*
* **COLLECTIONS** - Single variable that can hold multiple values * An array, or a table*


## RECORD

A `RECORD` in PL/SQL is a composite variable that groups multiple related values (called fields), similar to:
* A row in a table
* A struct in C
* An object without methods

Each field can have a different data type, and you access them using dot notation (`record_name.field_name`).

### Declaring a RECORD

#### %ROWTYPE
This automatically creates a RECORD that matches the structure of a table or view.

```
DECLARE
  v_emp employees%ROWTYPE;
BEGIN
  SELECT * INTO v_emp FROM employees WHERE id = 101;
  DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp.name || ', Salary: ' || v_emp.salary);
END;
```

#### TYPE ... IS RECORD (Custom Definition)
Gives you full control over the structure and fields.

```
DECLARE
  TYPE emp_record_type IS RECORD (
    id employees.id%TYPE,
    name employees.name%TYPE,
    hire_date DATE
  );

  v_emp emp_record_type;
BEGIN
  v_emp.id := 105;
  v_emp.name := 'Alex';
  v_emp.hire_date := SYSDATE;

  DBMS_OUTPUT.PUT_LINE('ID: ' || v_emp.id || ', Name: ' || v_emp.name);
END;
```

### Accessing RECORD Fields
You access each field using dot notation:

```
v_emp.name := 'Maria';
DBMS_OUTPUT.PUT_LINE(v_emp.name);
```

### Using RECORDs in SELECT INTO

```
DECLARE
  v_emp employees%ROWTYPE;
BEGIN
  SELECT * INTO v_emp
  FROM employees
  WHERE id = 101;

  DBMS_OUTPUT.PUT_LINE('Salary: ' || v_emp.salary);
END;
```

### RECORDs in Loops (Cursor FOR Loop)
A powerful use case: process query results row-by-row.

```
FOR emp_rec IN (SELECT id, name FROM employees) LOOP
  DBMS_OUTPUT.PUT_LINE('ID: ' || emp_rec.id || ', Name: ' || emp_rec.name);
END LOOP;
```

### RECORDs in Procedures and Functions
You can pass records as IN, OUT, or IN OUT parameters.

```
PROCEDURE show_employee(p_emp IN employees%ROWTYPE) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Name: ' || p_emp.name);
END;
```

### Nested RECORDs (Advanced)
You can nest one record inside another:

```
DECLARE
  TYPE address_type IS RECORD (
    city VARCHAR2(50),
    zip  VARCHAR2(10)
  );

  TYPE person_type IS RECORD (
    name VARCHAR2(100),
    address address_type
  );

  v_person person_type;
BEGIN
  v_person.name := 'Alex';
  v_person.address.city := 'Iasi';
  v_person.address.zip := '700000';

  DBMS_OUTPUT.PUT_LINE(v_person.name || ' lives in ' || v_person.address.city);
END;
```


## COLLECTIONS

A collection is a single variable that can hold multiple values, like an array or list.

PL/SQL supports three types of collections:

| Collection Type                    | Description                     | Indexed By        | Size Bound? | Persist in SQL? |
| ---------------------------------- | ------------------------------- | ----------------- | ----------- | --------------- |
| **Associative Array** (`INDEX BY`) | Key-value pair (sparse)         | Integer or String | No          | No              |
| **Nested Table**                   | Unbounded array (can have gaps) | Integer           | No          | Yes (as column) |
| **VARRAY**                         | Ordered, fixed-size array       | Integer           | Yes         | Yes             |

### Associative Arrays (INDEX BY Tables)
Also called index-by tables, they're sparse, unbounded, and perfect for dynamic, memory-based lookups.

```
DECLARE
  TYPE num_table IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  v_nums num_table;

BEGIN
  v_nums(1) := 100;
  v_nums(5) := 500;

  DBMS_OUTPUT.PUT_LINE('v_nums(1) = ' || v_nums(1));
  DBMS_OUTPUT.PUT_LINE('v_nums(5) = ' || v_nums(5));
END;
```

[Example](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/Associative%20Arrays.sql)

### Nested Tables
Think of it as an unbounded array that can be used in both PL/SQL and database columns. Can be extended, deleted, truncated, and even stored in a table column as a collection.

```
DECLARE
  TYPE name_list IS TABLE OF VARCHAR2(100);
  v_names name_list := name_list('Alex', 'Maria', 'John');

BEGIN
  FOR i IN 1..v_names.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_names(i));
  END LOOP;
END;
```

[Example](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/Nested%20Tables.sql)

### VARRAY (Variable-Size Arrays)
Like nested tables, but with a fixed maximum size. When you define a VARRAY, you must declare the maximum size upfront. Stored in order and ideal when you need compact, bounded arrays.

Key Characteristics:
- Ordered (you access elements by index)
- Has a maximum number of elements (VARRAY(n))
- Stored as a single object (compact and efficient)
- Can be persisted in tables

```
DECLARE
  TYPE score_array IS VARRAY(5) OF NUMBER;
  v_scores score_array := score_array(85, 90, 75);

BEGIN
  FOR i IN 1..v_scores.COUNT LOOP
    DBMS_OUTPUT.PUT_LINE('Score: ' || v_scores(i));
  END LOOP;
END;
```

[Example VARRAY](https://github.com/alexandruavram-rusu/Documentation/blob/main/SQL/PLs/PLSQL/Examples/VARRAYS.sql)

## Collection Methods (Shared Across Types)

| Method      | Description                                          | Applicable To                |
| ----------- | ---------------------------------------------------- | ---------------------------- |
| `COUNT`     | Returns the **number of elements** in the collection | All collections              |
| `EXISTS(i)` | Checks if **element at index `i` exists**            | All collections              |
| `FIRST`     | Returns **lowest index** currently defined           | All collections              |
| `LAST`      | Returns **highest index** currently defined          | All collections              |
| `PRIOR(i)`  | Returns **previous defined index** before `i`        | All collections              |
| `NEXT(i)`   | Returns **next defined index** after `i`             | All collections              |
| `DELETE`    | Deletes elements (single or all)                     | Nested tables, Assoc. arrays |
| `TRIM`      | Removes elements from **end** of collection          | Nested tables, VARRAYs       |
| `EXTEND`    | Adds empty elements to **end** of collection         | Nested tables, VARRAYs       |


| Method   | Assoc. Array | Nested Table | VARRAY |
| -------- | ------------ | ------------ | ------ |
| `COUNT`  | ✅            | ✅            | ✅      |
| `EXISTS` | ✅            | ✅            | ✅      |
| `FIRST`  | ✅            | ✅            | ✅      |
| `LAST`   | ✅            | ✅            | ✅      |
| `PRIOR`  | ✅            | ✅            | ✅      |
| `NEXT`   | ✅            | ✅            | ✅      |
| `DELETE` | ✅            | ✅            | ❌      |
| `TRIM`   | ❌            | ✅            | ✅      |
| `EXTEND` | ❌            | ✅            | ✅      |



### COUNT

```
v_list.COUNT;
```


```
DECLARE
  TYPE numlist IS TABLE OF NUMBER;
  v_nums numlist := numlist(10, 20, 30);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Count = ' || v_nums.COUNT);  -- Output: 3
END;
```

### EXISTS(i)
Returns TRUE if the index `i` is defined in the collection.

```
IF v_list.EXISTS(3) THEN ...
```

```
IF v_nums.EXISTS(5) THEN
  DBMS_OUTPUT.PUT_LINE('Index 5 exists!');
ELSE
  DBMS_OUTPUT.PUT_LINE('Index 5 does not exist.');
END IF;
```

### FIRST / LAST
Returns the first or last index value in the collection (not the value itself).

```
v_list.FIRST;  -- often 1
v_list.LAST;   -- depends on collection size
```

```
DBMS_OUTPUT.PUT_LINE('First index: ' || v_nums.FIRST);
DBMS_OUTPUT.PUT_LINE('Last index: ' || v_nums.LAST);
```

### PRIOR(i) / NEXT(i)
Get previous or next existing index relative to `i`.

```
v_list.PRIOR(3);  -- returns 2
v_list.NEXT(3);   -- returns 4
```

### DELETE
Removes elements from the collection. Not allowed on VARRAYs.

Variants:
* `DELETE` → removes all elements
* `DELETE(i)` → removes only index `i`
* `DELETE(i, j)` → removes a range

```
v_nums.DELETE(2);      -- Delete only index 2
v_nums.DELETE(1, 3);   -- Delete indexes 1 to 3
v_nums.DELETE;         -- Delete all elements
```

### TRIM
Removes elements from the end of the collection. Not allowed on associative arrays.

Variants:
* `TRIM;` → removes last element
* `TRIM(n);` → removes last `n` elements

```
v_nums.TRIM;       -- Removes last element
v_nums.TRIM(2);    -- Removes last 2 elements
```

### EXTEND
Adds empty elements to the end of a collection. Not for associative arrays.

Variants:
* `EXTEND;` → adds one null element
* `EXTEND(n);` → adds n elements
* `EXTEND(n, i);` → adds n copies of element at index `i`

```
v_nums.EXTEND(2);  -- Add 2 empty elements
v_nums(4) := 100;
v_nums.EXTEND(1, 4);  -- Copy value from index 4
```

### Real-World Example: Looping with FIRST/NEXT


```
DECLARE
  -- Declare an associative array mapping integer keys to employee names
  TYPE emp_map IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
  v_employees emp_map;

  -- Declare a loop variable
  i PLS_INTEGER;
BEGIN
  -- Assign values to specific indexes (sparse keys: 1, 3, 5)
  v_employees(1) := 'Alex';
  v_employees(3) := 'Maria';
  v_employees(5) := 'John';

  -- Initialize loop with the FIRST defined index
  i := v_employees.FIRST;

  -- Loop while there's a valid index
  WHILE i IS NOT NULL LOOP
    -- Output the current index and its associated value
    DBMS_OUTPUT.PUT_LINE('[' || i || '] ' || v_employees(i));

    -- Move to the next defined index
    i := v_employees.NEXT(i);
  END LOOP;
END;
```
