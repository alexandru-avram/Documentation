# Using SQL in PL/SQL

PL/SQL is an extension of SQL. Inside PL/SQL blocks, you can:
* Query data using `SELECT INTO`
* Use DML to manipulate data using `INSERT`, `UPDATE`, `DELETE`
* Use DDL (like `CREATE`, `DROP`) indirectly through dynamic SQL


## Data Query

`SELECT INTO` retrieves a single row of data and stores it in variables.

```
SELECT column1, column2
INTO variable1, variable2
FROM table
WHERE condition;
```

* Always use filters (e.g., `WHERE ROWNUM = 1`) if unsure!
* Throws `NO_DATA_FOUND` if no rows returned
* Throws `TOO_MANY_ROWS` if more than one row is returned

Example:

```
DECLARE
  v_name employees.name%TYPE;
  v_salary employees.salary%TYPE;
BEGIN
  SELECT name, salary
  INTO v_name, v_salary
  FROM employees
  WHERE id = 101;

  DBMS_OUTPUT.PUT_LINE('Name: ' || v_name || ', Salary: ' || v_salary);
END;
```

### DML - Data Manipulation

DML stands for Data Manipulation Language. It includes SQL commands used to query or modify data inside tables — without affecting the structure of the database.

These statements work the same as in SQL, just without `INTO`, and often use PL/SQL variables.

#### INSERT

```
DECLARE
  v_name VARCHAR2(50) := 'Alex';
  v_salary NUMBER := 6000;
BEGIN
  INSERT INTO employees(name, salary)
  VALUES (v_name, v_salary);
END;
```

#### UPDATE

```
BEGIN
  UPDATE employees
  SET salary = salary + 1000
  WHERE id = 101;
END;
```

#### DELETE

```
BEGIN
  DELETE FROM employees
  WHERE name = 'TestUser';
END;
```

#### MERGE

```
MERGE INTO employees e
USING (SELECT 101 AS id, 'Alex' AS name FROM dual) src
ON (e.id = src.id)
WHEN MATCHED THEN
  UPDATE SET e.name = src.name
WHEN NOT MATCHED THEN
  INSERT (id, name) VALUES (src.id, src.name);
```

#### Example block

```
DECLARE
  v_id NUMBER := 103;
  v_name VARCHAR2(50) := 'John';
BEGIN
  -- INSERT
  INSERT INTO employees (id, name) VALUES (v_id, v_name);

  -- UPDATE
  UPDATE employees SET name = 'John Updated' WHERE id = v_id;

  -- SELECT
  SELECT name INTO v_name FROM employees WHERE id = v_id;

  -- DELETE
  DELETE FROM employees WHERE id = v_id;

  DBMS_OUTPUT.PUT_LINE('Done processing employee');
END;
```

#### Transaction Control for DML
DML does not auto-commit — changes are pending until you `COMMIT`.

```
BEGIN
  UPDATE employees SET salary = 7000 WHERE id = 101;
  SAVEPOINT before_delete;

  DELETE FROM employees WHERE id = 105;

  ROLLBACK TO before_delete;  -- Undo the delete, keep the update

  COMMIT;
END;
```

## DDL Statements - Data Definition
DDL (Data Definition Language) consists of SQL commands used to define or change the schema of the database — i.e., tables, columns, constraints, users, views, etc.

Unlike DML, DDL statements:
* Directly affect database structure
* Auto-commit (you can’t undo them with `ROLLBACK`)
* Cannot be used directly inside PL/SQL blocks (must use dynamic SQL)

When you run any DDL command:
* Oracle automatically performs a `COMMIT` before and after the DDL.
* Any uncommitted changes are also committed — even if you didn't want that.

Common statements that can be used in PL/SQL:
* `CREATE`
* `ALTER`
* `DROP`
* `TRUNCATE`
* `RENAME`

#### EXECUTE IMMEDIATE
You cannot write DDL directly inside PL/SQL blocks because of the compile-time parsing restriction. Instead, use dynamic SQL with `EXECUTE IMMEDIATE`.

```
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE temp_table (id NUMBER, value VARCHAR2(50))';
  
  EXECUTE IMMEDIATE 'ALTER TABLE temp_table ADD (created_at DATE)';
  
  EXECUTE IMMEDIATE 'DROP TABLE temp_table';
END;
```

#### Using Variables in DDL

Example:

```
DECLARE
  v_table_name VARCHAR2(50) := 'log_' || TO_CHAR(SYSDATE, 'YYYYMMDD');
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE ' || v_table_name || ' (id NUMBER, log_text VARCHAR2(100))';
END;
```
