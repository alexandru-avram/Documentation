# User Defined Elements (Functions, Procedures, Data Types)


- [USER-DEFINED FUNCTIONS (UDFs)](#user-defined-functions-udfs)
- [STORED PROCEDURES](#stored-procedures)
- [INLINE TABLE-VALUED FUNCTIONS](#inline-table-valued-functions-t-sql)
- [COMMON TABLE EXPRESSIONS (CTEs)](#common-table-expressions-ctes)
- [USER-DEFINED DATA TYPE](#user-defined-data-type)
  - [CREATE DOMAIN](#create-domain)
  - [CREATE TYPE](#create-type)
  - [DROP DOMAIN](#drop-domain)


<BR>

### USER-DEFINED FUNCTIONS (UDFs)
A User-Defined Function (UDF) in SQL is a custom function created by the user to encapsulate a specific piece of logic. UDFs take parameters, perform a computation, and return a single value.

```
CREATE FUNCTION CalculateDiscount(price DECIMAL, discount_rate DECIMAL)
RETURNS DECIMAL
BEGIN
  DECLARE discounted_price DECIMAL;
  SET discounted_price = price - (price * discount_rate);
  RETURN discounted_price;
END;
```

### STORED PROCEDURES
A Stored Procedure is a precompiled collection of one or more SQL statements that can be executed as a single unit. Stored Procedures are typically used to encapsulate business logic, perform operations on the database, or execute a series of SQL statements. They can accept parameters, return values, and can be executed by other programs or scripts.

```
CREATE PROCEDURE UpdateEmployeeSalary(employee_id INT, new_salary DECIMAL)
BEGIN
  UPDATE employees
  SET salary = new_salary
  WHERE id = employee_id;
END;
```

### INLINE TABLE-VALUED FUNCTIONS (T-SQL)
Similar to UDFs, Inline Table-Valued Functions return a table as a result. They can be used in the FROM clause of a SELECT statement, and their results can be treated like a regular table. 

This concept is specific only for T-SQL servers.

```
CREATE FUNCTION GetEmployeesByDepartment(@dept_id INT)
RETURNS TABLE
AS
RETURN (
  SELECT * FROM employees WHERE department_id = @dept_id
);
```

### COMMON TABLE EXPRESSIONS (CTEs)
CTEs provide a way to define temporary result sets within a SELECT, INSERT, UPDATE, or DELETE statement. They make complex queries more readable by breaking them down into smaller, named, and reusable units.

```
WITH MonthlySales AS (
  SELECT employee_id, SUM(sales_amount) AS total_sales
  FROM sales
  WHERE DATE_PART('month', sale_date) = DATE_PART('month', CURRENT_DATE)
  GROUP BY employee_id
)
SELECT * FROM MonthlySales WHERE total_sales > 10000;
```

<BR>


## USER-DEFINED DATA TYPES

### CREATE DOMAIN
`CREATE DOMAIN` allows you to define a new data type with optional constraints. It's useful when you need to ensure consistency and enforce rules for a specific type of data across multiple columns or tables.

```
CREATE DOMAIN domain_name AS data_type [DEFAULT default_value] [CHECK constraint];
```

**Example (email address)**

```
CREATE DOMAIN EmailAddress VARCHAR(255) NOT NULL
CHECK (VALUE LIKE '%@%.%');
```

**Example ENUM or SET values**

```
CREATE DOMAIN colors VARCHAR(30) NOT NULL
CHECK (VALUE IN ('red', 'blue', 'yellow'));
```

### CREATE TYPE
`CREATE TYPE` enables you to define a new composite type or custom data type in PostgreSQL. It's handy when you want to bundle together multiple fields under a single data type, especially if you intend to reuse that structure across tables or queries.

```
CREATE TYPE type_name AS (attribute1 data_type, attribute2 data_type, ...);
```

**Example full address**
```
CREATE TYPE AddressType AS (
  street_address VARCHAR(255),
  city VARCHAR(100),
  state CHAR(2),
  zip_code VARCHAR(10)
);
```

### DROP DOMAIN
Delete a custom domain created on the schema.

```
DROP DOMAIN domain_name
```

If the domain is used, it will not be deleted unless you use `CASCADE`. However, unless you want to loose the data on the columns using a custom domain-type, ensure you ALTER the data type on the columns.

```
DROP DOMAIN domain_name CASCADE
```
