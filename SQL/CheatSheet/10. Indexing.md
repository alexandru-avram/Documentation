# Indexing

- [About Indexing](#about-indexing)
  - [How Does an Index Work](#how-does-an-index-work)
  - [When to Create an Index](#when-to-create-an-index)
  - [Beneftis of Indexes](#beneftis-of-indexes)
  - [Drawbacks and Trade-offs](#drawbacks-and-trade-offs)
- [Types of Indexes](#types-of-indexes)
  - [Single-Column vs Composite](#single-column-vs-composite)
  - [Clustered vs Non-Clustered](#clustered-vs-non-clustered)
  - [Unique Index](#unique-index)
  - [Full-Text Index](#full-text-index)
  - [Bitmap Index](#bitmap-index)
  - [Hash Index](#hash-index)
  - [Possible Combinations](#possible-combinations)
- [Other Index Operations](#other-index-operations)
  - [Drop](#drop)
  - [Rebuild](#rebuild)
  - [Reorganize](#reorganize)
  - [Disable](#disable)
  - [Enable](#enable)
  - [Rename](#rename)
  - [Viewing Index Information](#view-index-information)
- [USING Method](#using-method)
- [Best Practices](#best-practice)
- [Things to Avoid](#things-to-avoid)
- [Naming Conventions](#naming-conventions)
- [Explain](#explain)


<br>

## About Indexing

An index in SQL is a data structure that improves the speed of data retrieval operations on a database table. Similar to the index at the back of a book, an SQL index allows the database to find specific rows faster by minimizing the need to scan the entire table for the desired data.

Indexes provide a sorted reference to the rows in a table, which can dramatically enhance the performance of SELECT queries, especially when working with large datasets. However, while indexes speed up read operations, they can also introduce some overhead during write operations (like `INSERT`, `UPDATE`, and `DELETE`).

### How does an Index Work

1. **Data Structure**: Most indexes are implemented using a **B-tree** (balanced tree) or a hash table, depending on the database system and the type of index.
   - **B-tree indexes**: These are the most common types of indexes, where data is stored in a balanced tree structure. This allows for fast searching, inserting, and deleting, all in logarithmic time `(O(log n)` complexity). B-trees are used for range queries (e.g., finding records between two values) and queries that require sorted data.
   - **Hash indexes**: These use a hash table to quickly look up data based on equality comparisons (`=`). Hash indexes are fast for exact matches but are not useful for range queries.
2. **Lookup**: When a query is executed, the database engine checks the available indexes to see if one can be used. If an index exists on the column(s) being queried (e.g., in the `WHERE` or `JOIN` clause), the index allows the database to find the relevant rows quickly without scanning the entire table.
3. **Pointers**: Indexes store pointers to the actual rows in the table. These pointers allow the database to quickly locate and retrieve the relevant rows once the index lookup has been performed.

### When to Create an Index
1. **High Selectivity**: Columns with many unique values (high cardinality) are good candidates for indexing. For example, a column like employee_id or email will benefit more from an index than a column with low cardinality, such as gender (with only two possible values).
2. **Frequent Filtering or Sorting**: Columns that are frequently used in `WHERE`, `JOIN`, `ORDER BY`, or `GROUP BY` clauses should be indexed. This will speed up filtering, joining, and sorting operations.
3. **Foreign Keys**: It’s a good practice to index foreign key columns to improve the performance of joins between related tables.

### Benefits of Using Indexes
#### Faster Query Performance:
Indexes can dramatically speed up SELECT queries that use WHERE, JOIN, ORDER BY, and GROUP BY clauses by reducing the amount of data the database needs to scan.
For example, if you frequently query employees by their last_name, an index on last_name will make these queries much faster.

#### Efficient Sorting and Searching:
Indexes allow the database to sort and search rows efficiently. Without an index, sorting would require scanning the entire table, but an index can store data in a sorted manner, improving performance for operations like ORDER BY.

#### Reduced I/O Operations:
By limiting the number of rows scanned, indexes reduce the number of disk I/O operations, which is crucial for database performance, especially on large tables.

### Drawbacks and Trade-offs of Indexes
#### Increased Storage:
Indexes require additional storage because the database needs to maintain separate index structures. For large tables, indexes can consume significant disk space, especially when multiple columns are indexed.

#### Slower Write Performance:
Indexes slow down write operations like INSERT, UPDATE, and DELETE because the index must be updated whenever the data in the indexed column changes. Each time a new row is added or an existing row is modified, the database needs to insert, delete, or update corresponding entries in the index.
For tables with heavy write activity, the overhead of maintaining indexes can outweigh the benefits of faster reads.

#### Index Fragmentation:
Over time, indexes can become fragmented due to frequent data modifications. This fragmentation can slow down query performance and require periodic maintenance operations like rebuilding or reorganizing the index to keep it efficient.

#### Over-indexing:
While indexes improve query performance, creating too many indexes can lead to diminishing returns. Every additional index consumes more storage and further slows down write operations. It is important to carefully balance the number of indexes based on actual query patterns.



<BR>

## Types of Indexes

### Single-Column vs Composite

#### Single-Column
A single-column index is created on only one column of a table. It's the most basic type of index.

```
CREATE INDEX idx_column_name ON table_name(column_name);
```

#### Composite Index (Multi-Column Index)
A composite index is an index on two or more columns of a table. This type of index is useful when queries often filter or sort data based on multiple columns. However, the order of the columns in the composite index matters, as queries must use the indexed columns in the same order.

- Indexes multiple columns in the same index.
- Queries that filter on the leading column(s) will benefit the most from the index.
- Good for queries with `WHERE`, `JOIN`, or `ORDER BY` clauses that involve multiple columns.
- Composite indexes are most effective when the query uses the columns in the order they are indexed.

```
CREATE INDEX idx_composite ON table_name(column1, column2);
```

### Clustered vs Non-Clustered

#### Clustered Index
A clustered index determines the physical order of the rows in the table. This means that the table rows are stored in the order specified by the clustered index. Because of this, a table can only have one clustered index, as there can only be one physical order of rows in a table.

- The data itself is sorted in the order of the clustered index.
- Queries that retrieve ranges of data are faster with a clustered index.
- Often used for columns with unique, incremental values (e.g., `ID`, `date`).
- In most databases, a clustered index is automatically created when defining a primary key.

```
CREATE CLUSTERED INDEX idx_clustered ON table_name(column_name);
```

#### Non-Clustered Index
A non-clustered index is separate from the table data and stores pointers to the actual rows in the table. You can have multiple non-clustered indexes on a table, making it a versatile option for optimizing specific query operations.

- The data is not stored in the order of the non-clustered index.
- Non-clustered indexes create a lookup table that holds the index and pointers to the actual data.
- You can create multiple non-clustered indexes on a table.
- Useful for optimizing columns frequently used in WHERE, JOIN, or ORDER BY clauses.

```
CREATE INDEX idx_nonclustered ON table_name(column_name);
```

### Unique Index
A unique index guarantees that no two rows in the table can have the same value for the indexed column(s). This type of index is used to enforce uniqueness on a column, similar to a UNIQUE constraint, but it also optimizes query performance.

- Ensures that all values in the indexed column(s) are unique.
- Useful for columns that should have unique values but are not the primary key.
- Helps in scenarios where data integrity and query performance are both important.

```
CREATE UNIQUE INDEX idx_unique_column ON table_name(column_name);
```

### Full-Text Index
A full-text index is used to optimize searching for text-based data within large columns such as `TEXT` or `VARCHAR`. It is especially useful for scenarios where you need to perform text searches on large textual fields, such as searching for keywords or phrases.

- Used for efficient text searching (e.g., finding words or phrases in text).
- Suitable for columns with large amounts of text data.
- Supported by specific database engines like MySQL and SQL Server.
- Improves performance for queries involving MATCH or CONTAINS in text columns.

```
CREATE FULLTEXT INDEX idx_fulltext ON table_name(column_name);
```

### Bitmap Index
A bitmap index is typically used in data warehousing environments and is most effective for columns with low cardinality (i.e., columns with few distinct values). This type of index uses bitmaps and is very efficient for read-heavy operations, but it is not ideal for tables with frequent updates.

- Best suited for columns with low cardinality (few distinct values).
- Common in read-heavy environments like data warehouses.
- Not ideal for transactional tables with frequent updates or inserts.
-  Bitmap indexes are supported by specific database systems, such as **Oracle**.

```
CREATE BITMAP INDEX idx_bitmap ON table_name(column_name);
```

### Hash Index
A hash index is used when you need fast lookups for equality comparisons (i.e., using `=` in queries). Unlike other index types, hash indexes are not well-suited for range queries (e.g., using `BETWEEN` or `<`/`>`). Hash indexes are most common in in-memory databases or systems optimized for fast, constant-time lookups.

- Optimized for equality comparisons (`=`).
- Not suitable for range queries.
- Common in NoSQL databases or in-memory systems (e.g., Redis, MySQL’s MEMORY storage engine).

```
CREATE INDEX idx_hash ON table_name(column_name) USING HASH;
```

### Possible Combinations

| **Combination** | **Possible** | **Description** | 
| --- | --- | --- | 
| **Clustered + Unique** | Yes | Ensures unique values while organizing the data in physical order. |
| **Non-Clustered + Unique** | Yes | Ensures unique values without changing the physical order of the data. |
| **Clustered + Composite** | Yes | Orders the table based on multiple columns. |
| **Non-Clustered + Composite**| Yes | Non-clustered multi-column index for optimizing multi-column queries. |
| **Clustered + Primary Key** |	Yes	| By default, the primary key is often a clustered index. |
| **Non-Clustered + Primary Key** |	Yes |	Primary key is enforced without changing the physical order of the rows. |
| **Full-Text + Non-Clustered** |	Yes	| Optimizes text searches while also indexing other columns for quick lookups. |
| **Full-Text + Primary Key** |	Yes |	Full-text search capability combined with a primary key (which is often clustered). |
| **Full-Text + Clustered** |	No |	Full-text indexes cannot determine the physical order of rows. |
| **Full-Text + Unique** |	No |	Full-text indexing does not support enforcing uniqueness of values. |
| **Clustered + Full-Text on Same Column** |	No |	Cannot combine both on the same column as they serve different purposes. |

<BR>

## Other Index Operations

### Drop
If an index becomes unnecessary or impacts performance negatively, you can drop it using the following syntax:

```
DROP INDEX idx_name ON table_name;
```

### Rebuild
Over time, indexes can become fragmented due to data modifications (inserts, updates, and deletes), which can degrade performance. Rebuilding an index reorganizes the index's data and reduces fragmentation, which can improve query performance.

```
ALTER INDEX idx_name ON table_name REBUILD;
```

### Reorganize
Reorganizing an index is a lighter-weight operation than rebuilding it. While rebuilding completely re-creates the index, reorganizing defragments it without entirely recreating it.

Not all database systems differentiate between reorganizing and rebuilding indexes. In systems like MySQL, you typically just rebuild the index.

```
ALTER INDEX idx_name ON table_name REORGANIZE;
```

### Disable
Disabling an index prevents it from being used by the query optimizer but keeps the index definition in the database. This can be useful for testing performance impacts or temporarily disabling the index during bulk operations. Disabling indexes is useful in ETL processes or when performing bulk inserts to avoid the overhead of index updates.

```
ALTER INDEX idx_name ON table_name DISABLE;
```

### Enable
After disabling an index, you can enable it by rebuilding it. Enabling an index restores its functionality, allowing the query optimizer to use it again for queries.

```
ALTER INDEX idx_name ON table_name REBUILD;
```

### Rename
If you want to change the name of an existing index, you can rename it using the appropriate command. This is useful for keeping a consistent naming convention across your database schema.

```
ALTER TABLE table_name RENAME INDEX old_index_name TO new_index_name;
```

### Viewing Index Information
You can retrieve metadata about your indexes to understand their usage, size, and fragmentation levels. This is useful for monitoring index health and optimizing performance.

#### T-SQL
```
-- View index usage stats
SELECT * FROM sys.dm_db_index_usage_stats WHERE object_id = OBJECT_ID('table_name');

-- View index fragmentation
SELECT * FROM sys.dm_db_index_physical_stats(DB_ID(), OBJECT_ID('table_name'), NULL, NULL, 'DETAILED');
```

#### PostgreSQL
```
-- View index usage
SELECT * FROM pg_stat_user_indexes WHERE relname = 'table_name';

-- View index size
SELECT pg_size_pretty(pg_relation_size('index_name'));
```

#### Oracle

```
-- View index usage
SHOW INDEX FROM table_name;
```

<BR>

## USING Method
The `USING method` clause allows you to specify the indexing algorithm or method that the database should use to create the index. This is optional, and if omitted, the database typically defaults to the B-tree method (depending on the database system).

Different methods are used depending on the specific use case:
- **B-tree**: The default and most common index type. It’s great for range queries, sorting, and general-purpose lookups.
- **Hash**: Used for fast lookups when you are performing exact matches (e.g., WHERE id = 123). Not suitable for range queries (e.g., BETWEEN or >, <).
- **GiST** (Generalized Search Tree): Useful for more complex data types and queries (e.g., full-text search, spatial data).
- **GIN** (Generalized Inverted Index): Typically used in full-text searches or indexing arrays.
- **SP-GiST** (Space-Partitioned GiST): Suitable for multidimensional data.
- **BRIN** (Block Range INdex): Useful for very large datasets with ordered data, such as timestamped logs, to store index pointers in block ranges.

```
CREATE INDEX idx_example ON employees USING btree (last_name);
```

```
CREATE INDEX idx_employee_email ON employees USING hash(email);
```

#### (column_name [ASC | DESC]
This part specifies the column(s) to be indexed, along with the sorting order (ascending or descending).

- **ASC**: Sorts the index in ascending order. This is the default if no sorting is specified.
- **DESC**: Sorts the index in descending order.

```
CREATE INDEX idx_employee_lastname_asc ON employees(last_name ASC);
```

#### NULLS {FIRST | LAST}
The `NULLS FIRST | LAST` clause allows you to specify how NULL values should be treated in the index ordering. In SQL, NULL values are typically treated as either the lowest or highest possible value, depending on the database system and the sorting order used.

- **NULLS FIRST**: Ensures that NULL values appear before non-null values in the index.
- **NULLS LAST**: Ensures that NULL values appear after non-null values in the index.

```
CREATE INDEX idx_employee_lastname_nulls_first ON employees(last_name ASC NULLS FIRST);
```

#### Example of multi-index

```
CREATE INDEX idx_employee_name ON employees
USING btree (last_name ASC NULLS LAST, first_name DESC);
```

<BR>

## Best Practices
Effective indexing can dramatically improve query performance, but it requires careful planning and maintenance. Following best practices helps ensure that your indexes are optimized for your workload.

1. **Index Columns Used Frequently in Queries**: Indexes should be created on columns that are frequently used in `WHERE`, `JOIN`, `ORDER BY`, or `GROUP BY` clauses. These queries benefit the most from indexing because the index allows the database to filter and sort data more efficiently.
2. **Use Indexes on Foreign Key Columns**: Indexing foreign keys improves the performance of `JOIN` operations between related tables. Without an index on the foreign key, the database may need to perform a full table scan to locate matching rows.
3. **Limit the Number of Indexes on Write-Heavy Tables**: While indexes speed up read operations, they can slow down `INSERT`, `UPDATE`, and `DELETE` operations because the database needs to maintain the indexes as data changes. Limiting the number of indexes on write-heavy tables minimizes this overhead. Analyze the workload and only create essential indexes on tables that experience heavy write operations.
4. **Use Composite (Multi-Column) Indexes for Multi-Column Queries**: If your queries filter or sort by multiple columns, it’s better to create a composite index (covering multiple columns) rather than individual indexes on each column. This can significantly improve performance for queries that involve multiple columns in the `WHERE` clause or in sorting.
5. **Consider Indexing Columns Used in Sorting and Grouping**: Indexes can improve the performance of queries that include `ORDER BY` or `GROUP BY` clauses by providing the database with a sorted structure to retrieve data without performing an expensive sort operation.
6. **Monitor Index Usage and Fragmentation**: Over time, indexes can become fragmented, which can degrade performance. Regularly monitoring index usage and fragmentation helps you identify indexes that need to be rebuilt or reorganized to maintain optimal performance. Use database-specific tools to monitor index health and fragmentation, and perform regular index maintenance (e.g., `REBUILD` or `REORGANIZE`).

<BR>

## Things to Avoid
While indexes can improve performance, improper usage can lead to significant inefficiencies. Here are common mistakes to avoid.

1. **Avoid Over-Indexing**: Creating too many indexes on a table can negatively impact performance, especially for write-heavy tables. Each additional index adds overhead to `INSERT`, `UPDATE`, and `DELETE` operations, as the indexes need to be updated whenever the data changes.
2. **Avoid Indexing Columns with Low Cardinality**: Indexing columns with low cardinality (i.e., columns with few distinct values) often doesn’t improve performance. For example, columns like gender (which might have values like M or F) or boolean fields (with only true or false values) do not benefit much from indexing because the index will not significantly reduce the number of rows scanned.
3. **Avoid Redundant or Duplicate Indexes**: Redundant indexes are indexes that cover the same columns in the same order. These duplicate indexes waste storage space and increase the overhead of maintaining indexes without providing any additional benefit.
4. **Avoid Indexing Frequently Updated Columns**:  Indexes on columns that are frequently updated can lead to performance degradation because every time the indexed column changes, the index must be updated as well. This can significantly increase the cost of `UPDATE` operations.
5. **Don’t Index Small Tables**: Indexing very small tables is usually unnecessary because a full table scan can often be just as fast or faster than using an index. The overhead of maintaining the index may outweigh any performance gain for small datasets.

## Naming Conventions
Having a consistent naming convention for indexes helps make database maintenance easier, improves readability, and avoids confusion. A good naming convention should reflect the purpose of the index and the table/column(s) it indexes.

#### Prefix Convention
- **FORMAT**: `IDX_{table_name}_{column_name(s)}`
Use a prefix (`IDX_`) followed by the table name and the column(s) being indexed.

```
CREATE INDEX IDX_employees_last_name ON employees(last_name);
```

#### Prefix for Unique Indexes
- **FORMAT**: `UQ_{table_name}_{column_name(s)}`
For unique indexes, use a prefix like `UQ_`(for "unique") to distinguish them from non-unique indexes.

```
CREATE UNIQUE INDEX UQ_employees_email ON employees(email);
```

```
CREATE INDEX IDX_orders_customer_id_order_date ON orders(customer_id, order_date);
```

#### Prefix for Full-Text Indexes
- **FORMAT**: `FTX_{table_name}_{column_name}`
Use a `FTX_` prefix for full-text indexes to differentiate them from other index types.

```
CREATE FULLTEXT INDEX FTX_articles_content ON articles(content);
```

#### Prefix for Primary Key Indexes
- **FORMAT**: `PK_{table_name}`
For indexes that are associated with a primary key, use the `PK_` prefix followed by the table name.

```
CREATE UNIQUE CLUSTERED INDEX PK_employees ON employees(employee_id);
```

#### Prefix for Foreign Key Indexes
- **Format**: `FK_{table_name}_{referenced_table_name}`
Use `FK_` followed by the table name and the referenced table name for foreign key indexes. This helps identify the relationship between the two tables.

```
CREATE INDEX FK_orders_customers ON orders(customer_id);
```

## Explain
The `EXPLAIN` statement is a crucial tool in SQL for query performance analysis. It provides detailed insights into how a query will be executed, helping developers and DBAs identify bottlenecks and optimize queries for better performance. The `EXPLAIN` statement returns a query execution plan, showing how the database engine will retrieve the data, which indexes will be used, and the overall cost of executing the query.

The result is typically a step-by-step breakdown of how the query will be processed, including details like the use of indexes, joins, sorting, filtering, and estimated costs.

In some database systems, you may use variations like `EXPLAIN ANALYZE`, `EXPLAIN EXTENDED`, or `EXPLAIN FORMAT` 

Oracle uses `EXPLAIN PLAN`.


```
EXPLAIN SELECT * FROM table_name WHERE condition;
```

#### Components of the EXPLAIN Output
The output of EXPLAIN can vary across database systems, but it typically includes the following key fields:

1. **id**: This is a sequential identifier for the execution step. It helps you understand the order in which the operations will be performed.
2. **select_type**: This describes the type of query. For example, **SIMPLE** (no subqueries or unions), **PRIMARY** (outermost query in a `JOIN` or subquery), or **SUBQUERY** (for a query inside another query).
3. **table**: The name of the table being accessed at this step of the query execution.
4. **type**: This field shows the type of join or access method the query uses. This is one of the most important fields to watch. It indicates how efficiently the rows are being accessed:
  * **ALL**: Full table scan. This is usually a sign of inefficiency (try to avoid this).
  *  **index**: The database is scanning all the rows, but using an index instead of a full table scan.
  *  **range**: The database is scanning only a portion of the table, using an index to filter rows.
  *  **ref**: Rows are being matched based on an indexed column, typically in a join.
  *  **eq_ref**: The database uses a unique index for each row being joined, meaning it’s doing an efficient lookup.
  *  **const/system**: Very fast access. Only one matching row will be retrieved because of a constant comparison or optimization.

5. **possible_keys**: Shows the potential indexes that could be used to optimize the query based on the columns involved in `WHERE`, `JOIN`, or other conditions.
6. **key**: This indicates the actual index being used by the database for this query step.
7. **key_len**: The length of the index used in bytes. It helps determine how much of the index is being used.
8. **ref**: Shows the column(s) or constant(s) used to match rows against the index. This is often used in join operations to match values from one table to another.
9. **rows**: The estimated number of rows the database expects to scan or process in this step. This is an important metric, as fewer rows mean faster query execution. The higher the value, the more expensive the operation is likely to be.
10. **cost**: The output are estimates provided by the database query optimizer to help you understand the expected cost of executing different parts of a query. These costs are typically expressed as a combination of factors, such as the estimated number of rows to be processed, disk I/O, CPU usage, and memory usage. The lower the cost, the less expensive the operation is expected to be in terms of resource usage.
