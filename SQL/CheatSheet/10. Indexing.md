# Indexing

- [About Indexing](#about-indexing)
- [Types of Indexes](#types-of-indexes)
  - [Single-Column vs Composite](#single-column-vs-composite)
  - [Clustered vs Non-Clustered](#clustered-vs-non-clustered)
  - [Unique Index](#unique-index)
  - [Full-Text Index](#full-text-index)
  - [Bitmap Index](#bitmap-index)
  - [Hash Index](#hash-index)
  - [Possible Combinations](#possible-combinations)
- [Other Index Operations](#other-index-operations)
  - [Drop](#drop)
  - [Rebuild](#rebuild)
  - [Reorganize](#reorganize)
  - [Disable](#disable)
  - [Enable](#enable)
  - [Rename](#rename)
  - [Viewing Index Information](#view-index-information)
- [Best Practices](#best-practice)
- [Things to Avoid](#things-to-avoid)


<br>

## About Indexing

An index in SQL is a data structure that improves the speed of data retrieval operations on a database table. Similar to the index at the back of a book, an SQL index allows the database to find specific rows faster by minimizing the need to scan the entire table for the desired data.

Indexes provide a sorted reference to the rows in a table, which can dramatically enhance the performance of SELECT queries, especially when working with large datasets. However, while indexes speed up read operations, they can also introduce some overhead during write operations (like `INSERT`, `UPDATE`, and `DELETE`).

#### How does an Index Work?

1. **Data Structure**: Most indexes are implemented using a **B-tree** (balanced tree) or a hash table, depending on the database system and the type of index.
   - **B-tree indexes**: These are the most common types of indexes, where data is stored in a balanced tree structure. This allows for fast searching, inserting, and deleting, all in logarithmic time `(O(log n)` complexity). B-trees are used for range queries (e.g., finding records between two values) and queries that require sorted data.
   - **Hash indexes**: These use a hash table to quickly look up data based on equality comparisons (`=`). Hash indexes are fast for exact matches but are not useful for range queries.
2. **Lookup**: When a query is executed, the database engine checks the available indexes to see if one can be used. If an index exists on the column(s) being queried (e.g., in the `WHERE` or `JOIN` clause), the index allows the database to find the relevant rows quickly without scanning the entire table.
3. **Pointers**: Indexes store pointers to the actual rows in the table. These pointers allow the database to quickly locate and retrieve the relevant rows once the index lookup has been performed.

## Types of Indexes

### Single-Column vs Composite

#### Single-Column
A single-column index is created on only one column of a table. It's the most basic type of index.

```
CREATE INDEX idx_column_name ON table_name(column_name);
```

#### Composite Index (Multi-Column Index)
A composite index is an index on two or more columns of a table. This type of index is useful when queries often filter or sort data based on multiple columns. However, the order of the columns in the composite index matters, as queries must use the indexed columns in the same order.

- Indexes multiple columns in the same index.
- Queries that filter on the leading column(s) will benefit the most from the index.
- Good for queries with `WHERE`, `JOIN`, or `ORDER BY` clauses that involve multiple columns.
- Composite indexes are most effective when the query uses the columns in the order they are indexed.

```
CREATE INDEX idx_composite ON table_name(column1, column2);
```

### Clustered vs Non-Clustered

#### Clustered Index
A clustered index determines the physical order of the rows in the table. This means that the table rows are stored in the order specified by the clustered index. Because of this, a table can only have one clustered index, as there can only be one physical order of rows in a table.

- The data itself is sorted in the order of the clustered index.
- Queries that retrieve ranges of data are faster with a clustered index.
- Often used for columns with unique, incremental values (e.g., `ID`, `date`).
- In most databases, a clustered index is automatically created when defining a primary key.

```
CREATE CLUSTERED INDEX idx_clustered ON table_name(column_name);
```

#### Non-Clustered Index
A non-clustered index is separate from the table data and stores pointers to the actual rows in the table. You can have multiple non-clustered indexes on a table, making it a versatile option for optimizing specific query operations.

- The data is not stored in the order of the non-clustered index.
- Non-clustered indexes create a lookup table that holds the index and pointers to the actual data.
- You can create multiple non-clustered indexes on a table.
- Useful for optimizing columns frequently used in WHERE, JOIN, or ORDER BY clauses.

```
CREATE INDEX idx_nonclustered ON table_name(column_name);
```

### Unique Index
A unique index guarantees that no two rows in the table can have the same value for the indexed column(s). This type of index is used to enforce uniqueness on a column, similar to a UNIQUE constraint, but it also optimizes query performance.

- Ensures that all values in the indexed column(s) are unique.
- Useful for columns that should have unique values but are not the primary key.
- Helps in scenarios where data integrity and query performance are both important.

```
CREATE UNIQUE INDEX idx_unique_column ON table_name(column_name);
```

### Full-Text Index
A full-text index is used to optimize searching for text-based data within large columns such as `TEXT` or `VARCHAR`. It is especially useful for scenarios where you need to perform text searches on large textual fields, such as searching for keywords or phrases.

- Used for efficient text searching (e.g., finding words or phrases in text).
- Suitable for columns with large amounts of text data.
- Supported by specific database engines like MySQL and SQL Server.
- Improves performance for queries involving MATCH or CONTAINS in text columns.

```
CREATE FULLTEXT INDEX idx_fulltext ON table_name(column_name);
```

### Bitmap Index
A bitmap index is typically used in data warehousing environments and is most effective for columns with low cardinality (i.e., columns with few distinct values). This type of index uses bitmaps and is very efficient for read-heavy operations, but it is not ideal for tables with frequent updates.

- Best suited for columns with low cardinality (few distinct values).
- Common in read-heavy environments like data warehouses.
- Not ideal for transactional tables with frequent updates or inserts.
-  Bitmap indexes are supported by specific database systems, such as **Oracle**.

```
CREATE BITMAP INDEX idx_bitmap ON table_name(column_name);
```

### Hash Index
A hash index is used when you need fast lookups for equality comparisons (i.e., using `=` in queries). Unlike other index types, hash indexes are not well-suited for range queries (e.g., using `BETWEEN` or `<`/`>`). Hash indexes are most common in in-memory databases or systems optimized for fast, constant-time lookups.

- Optimized for equality comparisons (`=`).
- Not suitable for range queries.
- Common in NoSQL databases or in-memory systems (e.g., Redis, MySQLâ€™s MEMORY storage engine).

```
CREATE INDEX idx_hash ON table_name(column_name) USING HASH;
```

### Possible Combinations

| **Combination** | **Possible** | **Description** | 
| --- | --- | --- | 
| **Clustered + Unique** | Yes | Ensures unique values while organizing the data in physical order. |
| **Non-Clustered + Unique** | Yes | Ensures unique values without changing the physical order of the data. |



## Other Index Operations

### Drop
If an index becomes unnecessary or impacts performance negatively, you can drop it using the following syntax:

```
DROP INDEX idx_name ON table_name;
```



  - [Rebuild](#rebuild)
  - [Reorganize](#reorganize)
  - [Disable](#disable)
  - [Enable](#enable)
  - [Rename](#rename)
  - [Viewing Index Information](#view-index-information)
