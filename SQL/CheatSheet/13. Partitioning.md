- [PARTITION TYPES](#partition-types)
  - [RANGE PARTITIONING](#range-partitioning)
  - [LIST PARTITIONING](#list-partitioning)
  - [HASH PARTITIONING](#hash-partitioning)
  - [COMPOSITE PARTITIONING](#composite-partitioning)
- [MODIFYING PARTITIONS](#modifying-partitioning)
- [MANAGING PARTITIONED DATA](#managing-partitioned-data)
- [INDEXING PARTITIONS](#indexing-partitions)
- [SUBPARTITIONING](#subpartitioning)
- [PARTITION PRUNING](#partition-pruning)

<BR>

Partitioning divides a large table or index into smaller, more manageable pieces, while still maintaining the integrity of the entire dataset. It imporoves performance, maintenance and scalability.

# PARTITION TYPES

### RANGE PARTITIONING
Range partitioning divides data based on a range of values.

```
CREATE TABLE sales (
  id INT,
  sale_date DATE,
  amount DECIMAL
)
PARTITION BY RANGE (YEAR(sales_date)) (
  PARITITON p0 VALUES LESS THAN (2020),
  PARITITON p1 VALUES LESS THAN (2021),
  PARITITON p2 VALUES LESS THAN (2022)
);
```

### LIST PARTITIONING
List partitioning divides data based on a list of discrete values.

```
CREATE TABLE table1(
  id INT,
  column1 VARCHAR(100)
  column2 VARCHAR(100)
)
PARTITION BY LIST (column1) (
  PARTITION p0 VALUES IN (value 1),
  PARTITION p1 VALUES IN (value 2),
  PARTITION p2 VALUES IN (value 3)
);
```


### HASH PARTITIONING
Hash partitionintg distributes data evenly across partitions based on a hash function

```
CREATE TABLE table1 (
  id INT,
  column1 VARCHAR(100)
  column2 VARCHAR(100)
)
PARTITION BY HASH (id) PARTITIONS 4;
```


### COMPOSITE PARTITIONING
Composite partitioning combines two or more partitioning strategies, such as range-has or list-range partitioning.

```
CREATE TABLE orders (
  order_ID INT,
  order_date DATE,
  customer_id INT
)
PARTITION BY RANGE (YEAR(order_date))
  SUBPARTITION BY HASH (customer_id) SUBPARTITIONS 4 (
    PARTITION p0 VALUES LESS THAN (2020),
    PARTITION p1 VALUES LESS THAN (2021)
);
```

# MODIFYING PARTITION

### Adding a Partition

```
ALTER TABLE sales ADD PARTITION (
    PARTITION p3 VALUES LESS THAN (2023)
);
```

### Dropping a Parition

```
ALTER TABLE sales DROP PARTITION p0;
```

# MANAGING PARTITIONED DATA

### Merging Partitions

```
ALTER TABLE sales MERGE PARTITIONS p1, p2 INTO PARTITION p12;
```

### Splitting Partitions

```
ALTER TABLE sales SPLIT PARTITION p12 AT (2021) INTO (
    PARTITION p1, PARTITION p2
);
```

# INDEXING PARTITIONS
Indexes can be created on partitioned tables. Depending on the database, you can have global or local indexes.


### Local Index

```
CREATE INDEX idx_sales_date ON sales (sale_date) LOCAL;
```

### Global Index

```
CREATE INDEX idx_sales_amount ON sales (amount);
```

# SUBPARTITIONING

Subpartitionintg is an additional layer of partitionintg, where partitions are further divided into subpartitions. This helps with even finer-grained data management and can enhance performance, especially when managing large datasets. Subparitioning is typically used in complex schemas, where the first level of partitioning alone may not be sufficient. 

#### TYPES OF SUBPARTITIONING
- **Range-Range**: Both the partition and subpartition are divided by range (ex: dividing a table by year, and then further by month).
- **Range-Hash**: The table is first partitioned by range, and then each range is further subpartitioned by a hash function.
- **List-Hash**: The table is partitioned by a list of values, and then each range is further subpartitioned by a hash function.

```
CREATE TABLE orders (
    order_id INT,
    order_date DATE,
    customer_id INT,
    amount DECIMAL
)
PARTITION BY RANGE (YEAR(order_date))
SUBPARTITION BY HASH (customer_id) SUBPARTITIONS 4 (
    PARTITION p0 VALUES LESS THAN (2021),
    PARTITION p1 VALUES LESS THAN (2022),
    PARTITION p2 VALUES LESS THAN (2023)
);
```

# PARTITION PRUNING

Partition pruning is a performance optimization technique where the database engine only scans relevant partitions based on the queryâ€™s filter conditions. This significantly reduces the amount of data read, making queries faster and more efficient.

Use Partition Keys in `WHERE` Clause. To benefit from partition pruning, make sure your query filters on the partition key (e.g., `sale_date` in a range-partitioned table by date). Avoid Functions on Partition Keys, applying functions to partition keys (e.g., YEAR(sale_date) in the `WHERE` clause) can prevent pruning because the engine cannot determine the relevant partition in advance.

```
SELECT * FROM sales WHERE sale_date BETWEEN '2022-01-01' AND '2022-12-31';
```
