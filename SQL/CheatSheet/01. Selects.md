# SELECTING DATA

- [SYNTAX ORDER](#syntax-order)
- [SELECTING](#selecting)
  - [BASIC SELECT](#basic-select)
  - [DISTINCT](#distinct)
  - [ORDER BY](#order-by)
  - [FETCH and OFFSET](#fetch-and-offset)
  - [LIMIT (PG)](#limit-pg)
- [CONDITIONS](#conditions)
  - [WHERE](#where)
  - [AND](#and)
  - [OR](#or)
  - [BETWEEN](#between)
  - [LIKE](#like)
  - [NULL](#null)
  - [NOT NULL](#not-null)
  - [IN](#in)
  - [NOT IN](#not-in)
  - [CASE](#case)
- [GROUPING DATA](#grouping-data)
  - [GROUP BY](#group-by)
  - [HAVING](#having)
  - [ROLLUP](#rollup)
<br>

## SYNTAX ORDER
SELECT [DISTINCT]<br>
FROM<br>
WHERE<br>
GROUP BY<br>
HAVING<br>
ORDER BY<br>
LIMIT<br>

## SELECTING


### BASIC SELECT
The basic SQL SELECT statement retrieves data from one or more tables.

```
SELECT column1, column2, ...
FROM table_name;
```


### DISTINCT
Removes duplicate records from the result set.

```
SELECT DISTINCT column1, column2, ...
FROM table_name;
```

### ORDER BY
Sorts the result set in ascending or descending order.

```
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ASC|DESC];
```

### FETCH and OFFSET
The *OFFSET* statement in SQL is used in combination with the *ORDER BY* clause to retrieve a specified number of rows from the result set of a query. It is commonly used in scenarios where you want to paginate through a large result set, fetching a subset of rows at a time. The *FETCH* statement is often used in conjunction with *OFFSET* to skip a certain number of rows before retrieving the specified number of rows.

```
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ...
OFFSET {number_of_rows_to_skip} ROWS ONLY;
FETCH {number_of_rows_to_fetch} ROWS ONLY;
```

### LIMIT (PG)
Limits the number of rows returned. This is specific to Postgres.

```
SELECT column1, column2, ...
FROM table_name
LIMIT number_of_rows;
```


## Conditions

### WHERE
Filters the records based on a condition.

```
SELECT column1, column2
FROM table_name
WHERE column1 = 'value';
```

### AND
Multiple conditions are used to filter records using AND.

```
SELECT column1, column2
FROM table_name
WHERE column1 = 'value' AND column2 > 100;
```

### OR
Multiple conditions are used to filter records using OR.

```
SELECT column1, column2
FROM table_name
WHERE column1 = 'value' OR column2 > 100;
```

### BETWEEN
The *BETWEEN* condition is used to filter records within a specified range.

```
SELECT column1, column2
FROM table_name
WHERE column1 BETWEEN 50 AND 100;
```

The *NOT BETWEEN* condition is used to filter records outside a specified range.

```
SELECT column1, column2
FROM table_name
WHERE column1 NOT BETWEEN 50 AND 100;
```

### LIKE
The LIKE condition is used to search for a specified pattern in a column.

#### Wildcard *%*
Used to match any sequence of characters (including zero characters).

```
SELECT column1
FROM table_name
WHERE column1 LIKE 'A%';
```

#### Wildcard *_*
Used to match a single character.

```
SELECT column1
FROM table_name
WHERE column1 LIKE 'A_';
```

#### ILIKE (PG)
The *ILIKE* condition is specific to some database systems, such as **PostgreSQL**. It performs a case-insensitive pattern match similar to *LIKE*. This means it will match patterns regardless of the case of the letters.

```
SELECT * FROM employees WHERE first_name ILIKE 'a%';
```

### NULL
The NULL condition is used to filter records where a column has no value.

```
SELECT column1, column2
FROM table_name
WHERE column1 IS NULL;
```

### NOT NULL
Checks if a column does not have a NULL value.

```
SELECT *
FROM table_name
WHERE column_name IS NOT NULL;
```

### IN
Checks if a column's value is in a specified list.

```
SELECT *
FROM table_name
WHERE column_name IN (value1, value2, ...);
```

### NOT IN
Checks if a column's value is not in a specified list.

```
SELECT *
FROM table_name
WHERE column_name NOT IN (value1, value2, ...);
```

### CASE
Performs conditional logic within a query.

```
SELECT column1,
  CASE
    WHEN condition1 THEN 'Value1'
    WHEN condition2 THEN 'Value2'
    ELSE 'DefaultValue'
  END AS new_column
FROM table_name;
```

## GROUPING DATA

### GROUP BY
Groups rows that have the same values into summary rows.

```
SELECT column1, COUNT(column2)
FROM table_name
GROUP BY column1;
```

### HAVING
Filters the results of a `GROUP BY` clause.

```
SELECT column1, COUNT(column2)
FROM table_name
GROUP BY column1
HAVING COUNT(column2) > 1;
```

### ROLLUP
`ROLLUP` is an extension of the `GROUP BY` clause hat helps in generating subtotals and grand totals within a dataset. It's commonly used when you want to see aggregated data at multiple levels of grouping. It creates a hierarchy of groupings and calculates totals at each level, including an overall total.

```
SELECT column1, column2, ..., aggregate_function(column)
FROM table_name
GROUP BY ROLLUP (column1, column2, ...)
```
