## CONTROL FLOW

- [IF-ELSE](#if-else)
- [WHILE](#while)
- [FOR](#for)
- [GOTO](#goto)
- [TRANSACTIONS](#transactions)
  - [BEGIN TRANSACTION](#begin-transaction)
  - [COMMIT](#commit)
  - [ROLLBACK](#rollback)
  - [TRIGGER](#trigger)



<BR>

### IF-ELSE
Allows for conditional execution of SQL statements.

```
IF condition
BEGIN
  -- Statements to execute if condition is true
END
ELSE
BEGIN
  -- Statements to execute if condition is false
END;
```

### WHILE
Repeats a set of SQL statements as long as the specified condition is true.

WHILE condition
BEGIN
  -- Statements to execute
END;

### FOR
SQL Server doesn't have a native FOR loop like some other languages. Instead, you can use a WHILE loop with a counter.

```
DECLARE @counter INT = 1;

WHILE @counter <= 5
BEGIN
  PRINT 'Iteration: ' + CAST(@counter AS VARCHAR(10));
  SET @counter = @counter + 1;
END;
```

### GOTO
Allows for jumping to a specified label within a batch or stored procedure. Using GOTO is generally discouraged as it can make code harder to read and maintain. It's often better to use structured control flow constructs like IF-ELSE or CASE when possible.

```
IF condition
  GOTO label;

-- Statements to execute if condition is false

:label
-- Statements to execute if condition is true
```

<BR>

## TRANSACTIONS
Transactions in the context of databases refer to a set of one or more SQL statements that are executed as a single unit of work. The concept of transactions ensures that database operations are atomic, consistent, isolated, and durable, commonly known as the ACID properties.

### BEGIN TRANSACTION
Starts a new transaction. All subsequent SQL statements are part of this transaction until it is explicitly committed or rolled back.

```
BEGIN TRANSACTION;
```

### COMMIT
Saves all the changes made during the current transaction to the database. This makes the changes permanent.

```
COMMIT;
```

### ROLLBACK
Undoes all the changes made during the current transaction. It returns the database to its state before the transaction began.

```
ROLLBACK;
```

**Full example**

```
-- Start a new transaction
BEGIN TRANSACTION;

-- SQL statements within the transaction
UPDATE Accounts SET balance = balance - 100 WHERE account_id = 123;  -- Valid update
-- Simulate an error by attempting to update a non-existing account
UPDATE Accounts SET balance = balance - 100 WHERE account_id = 999;  -- Error: Account does not exist

-- Check for errors and decide whether to commit or roll back
IF @@ERROR <> 0
BEGIN
    -- An error occurred, roll back the entire transaction
    ROLLBACK;
    PRINT 'Transaction rolled back due to an error.';
END
ELSE
BEGIN
    -- No error occurred, commit the transaction, making the changes permanent
    COMMIT;
    PRINT 'Transaction committed successfully.';
END;
```

### TRIGGER
Triggers are powerful database objects that can automatically respond to events like INSERT, UPDATE, or DELETE on a table. They are useful for maintaining data integrity, logging changes, or enforcing business rules.

```
-- Create Trigger
CREATE TRIGGER trigger_name
AFTER INSERT OR UPDATE OR DELETE ON table_name
FOR EACH ROW
BEGIN
  -- trigger logic
END;
```

```
-- Example Trigger
DELIMITER //
CREATE TRIGGER after_insert_example
AFTER INSERT ON example_table
FOR EACH ROW
BEGIN
  INSERT INTO log_table (event_type, event_description, event_date)
  VALUES ('INSERT', CONCAT('New record added with ID: ', NEW.id), NOW());
END;
//

-- Drop Trigger
DROP TRIGGER IF EXISTS trigger_name;
```

In the example trigger above, a trigger named after_insert_example is created. It fires after each INSERT operation on the example_table. It logs the event into a log_table with details about the inserted record.
